Kind atm type. 

Import "../one-sided/mall".

%% Elements used in the specification of systems.

%% Object logic formulas and atoms
Kind olfm type.
Kind olatm type.

% The object logic contains atoms and binary connectives. These can possibly be
% augmented with higher arities connectives or quantifiers.
Type olatom olatm -> olfm.
Type olcon2 olfm -> olfm -> olfm.

%% The induction measure
%
% Either we instantiate is_olfm with a is_fm from a specification of a real
% logic or we use this more generic one. I see two reasons to use a generic
% one: (1) the theorem should not depend on the object logic; and (2) there
% will be less cases if we just have unnamed binary, terciary, etc.
% connectives.
%
Define is_olfm : olfm -> prop by
; is_olfm (olatom A)
; is_olfm (olcon2 A B) := is_olfm A /\ is_olfm B.

%% Mapping OL formulas to LL atoms
Type lft olfm -> atm.
Type rgt olfm -> atm.

%% Quantifiers for formulas of the object logic
%Type all (olfm -> o) -> o.
%Type ex (olfm -> o) -> o.

%% The specification of a formula maps the lft or rgt atoms to the body
Kind spec type.

Type spnil spec.
% Type spcons spec -> (olfm -> olfm -> atm) -> (olfm -> olfm -> o) -> spec.
Type spcons spec -> atm -> o -> spec.

%% There is a restriction regarding variables that can occur in the head and
%% body of a bipole that is not taken into account here.
Define is_spec : spec -> prop by
; is_spec spnil
; is_spec (spcons S (lft A) B) := is_spec S /\ is_olfm A /\ is_fm B
; is_spec (spcons S (rgt A) B) := is_spec S /\ is_olfm A /\ is_fm B.

%% build \mathcal{X}
Define translate : spec -> olist -> prop by
; translate spnil nil
; translate (spcons S H B) (F :: R) :=
    translate S R /\ 
%%    F = all OA\ all OB\ tens (natom (H OA OB)) (B OA OB).
    F = tens (natom H) B.

%% Define cut_coherent : spec -> prop by
%% TODO: define cut-coherence or prove it?

Theorem apply_def : forall J H B K L,
  adj J (tens (natom H) B) K ->
  adj K (atom H) L ->
  mall L ->
  exists LL,
  adj J B LL /\ mall LL.
skip.
%induction on 3. intros. case H3.
%  % Init (base case)
%  case H5.
%    case H2.
%      case H1. case H11.
%      case H9. case H11.
%    apply adj_nil_1 to H7. case H2. case H9.
%      case H1. case H13.
%      case H11.
%  % tensor
%  apply adj_swap to H1 H2.
%  apply adj_same_result_diff to H5 H12.
%  case H13.
% This is painfully hard.

    
Theorem to_atomic_cuts : forall Th0 Th1 Th B Br Bl Brd Bld Cut ACut,
  is_olfm B ->
  Cut = tens (atom (lft B)) (atom (rgt B)) ->
%  is_spec S -> translate S X ->
%  append X G Th ->
  % Spec is in the sequent
  adj Th0 (tens (natom (lft B)) Bl) Th1 ->
  adj Th1 (tens (natom (rgt B)) Br) Th ->
  % Spec is cut-coherent
  dual Br Brd -> dual Bl Bld ->
  adj nil Brd (Brd :: nil) -> adj (Brd :: nil) Bld (Brd :: Bld :: nil) ->
  mall (Brd :: Bld :: nil) -> % Do we need to add cut here?
  mall (Cut :: Th) ->
  exists A,
  ACut = tens (atom (lft (olatom A))) (atom (rgt (olatom A))) ->
  mall (ACut :: Th).

induction on 1. intros. case H2.
% Induction on B
case H1.
  % Case 1: the formula is atomic
  exists A. intros. case H11. search.
  % Case 2: the formula contains a connective
  case H10.
    % Casing on the linear logic proof with the non-atomic cut
    % How to deal with the cases where the tensor is not the first formula
    % to be decomposed?
    % Case 2.1: initial
    skip.
    % Case 2.2: tensor
    case H13.
      % Case 2.2.1: tensor is applied to the cut encoding
      apply adj_swap to H3 H4. apply merge_unadj_3 to H14 H4.
      case H23.
      % Note: if we had subexponentials and a classical context, this part
      % would be much less complicated because the specs would go to both
      % branches. That is also the right way to do this.

        skip. % spec on the wrong branch

        apply apply_def to H24 H17 H18. % Br is in LL1
        apply merge_unadj_3 to H14 H22. case H28.

          apply apply_def to H29 H15 H16. % Bl is in LL2
          % Cutting Bl
          apply adj_1_is_list to H31. apply adj_1_is_list to H8.
          apply merge_exists to H33 H34.
          apply mall_cut to H6 H31 H32 H8 H9 H35.
          % Cutting Br
          apply adj_swap to H7 H8. apply adj_nil_1 to H37.
          apply adj_1_is_list to H26. apply adj_1_is_list to H38.
          apply merge_exists to H39 H40.          
          apply mall_cut to H5 H26 H27 H38 H9 H41.
          % The induction hypothesis should be applied to mall L1 here
          % but I am not sure how yet.
          skip.

          skip. % spec on the wrong branch
      % Case 2.2.2: tensor is not applied to the cut encoding
      skip.
    % Case 2.3: par
    skip.
    % Case 2.4: bot
    skip.
    % Case 2.5: with
    skip.
    % Case 2.6: top
    skip.
    % Case 2.7: plus 1
    skip.
    % Case 2.8: plus 2
    skip.

