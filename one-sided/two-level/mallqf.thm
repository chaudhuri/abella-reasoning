Specification "mallq".

Set witnesses on.

Type form fm -> o.

Define is_fm : o -> prop by
; is_fm (form (atom A))
; is_fm (form (natom A))
; is_fm (form (tens A B)) := is_fm (form A) /\ is_fm (form B)
; is_fm (form one)
; is_fm (form (par A B)) := is_fm (form A) /\ is_fm (form B)
; is_fm (form bot)
; is_fm (form (wth A B)) := is_fm (form A) /\ is_fm (form B)
; is_fm (form top)
; is_fm (form (plus A B)) := is_fm (form A) /\ is_fm (form B)
; is_fm (form zero)
; is_fm (form (all A)) := nabla x, is_fm (form (A x))
; is_fm (form (exs A)) := nabla x, is_fm (form (A x))
.

Define is_pos : o -> prop by
; is_pos (form (atom A))
; is_pos (form (tens A B))
; is_pos (form one)
; is_pos (form (plus A B))
; is_pos (form zero)
; is_pos (form (exs A))
.

Define is_neg : o -> prop by
; is_neg (form (natom A))
; is_neg (form (wth A B))
; is_neg (form top)
; is_neg (form (par A B))
; is_neg (form bot)
; is_neg (form (all A))
.

Define is_neg_or_atom : o -> prop by
; is_neg_or_atom (form (atom A))
; is_neg_or_atom (form F) := is_neg (form F)
.

Define is_pos_or_atom : o -> prop by
; is_pos_or_atom (form (natom A))
; is_pos_or_atom (form F) := is_pos (form F)
.

Theorem dual_is : forall A B,
  { dual A B } -> is_fm (form A) /\ is_fm (form B).
induction on 1. intros. case H1.
  search.
  apply IH to *H2. apply IH to *H3. search.
  search.
  apply IH to *H2. apply IH to *H3. search.
  search.
  apply IH to *H2. search.

%% FYI: Abella cannot infer the type of A
Theorem is_fm_inst : forall (A : term -> o),
  nabla x, is_fm (A x) -> forall t, is_fm (A t).
induction on 1. intros. case H1.
  search.
  search.
  apply IH to H2. apply H4 with t = t.
    apply IH to H3. apply H6 with t = t.
    search.
  search.
  apply IH to H2. apply H4 with t = t.
    apply IH to H3. apply H6 with t = t.
    search.
  search.
  apply IH to H2. apply H4 with t = t.
    apply IH to H3. apply H6 with t = t.
    search.
  search.
  apply IH to H2. apply H4 with t = t.
    apply IH to H3. apply H6 with t = t.
    search.
  search.
  apply IH to H2 with A = (X\ form (A1 X n2)).
      apply H3 with t = t. search.
  apply IH to H2 with A = (X\ form (A1 X n2)).
    apply H3 with t = t. search.

Import "../../lib/merge" with is_o := is_fm.

Theorem is_list_inst : forall (L : term -> olist),
  nabla x, is_list (L x) -> forall t, is_list (L t).
induction on 1. intros. case H1.
  search.
  apply is_fm_inst to H2. apply H4 with t = t.
    apply IH to H3. apply H6 with t = t.
    search.

Theorem adj_inst : forall K A L,
  nabla (x : term), adj (K x) (A x) (L x) -> forall t, adj (K t) (A t) (L t).
induction on 1. intros. case H1.
  apply is_fm_inst to H2. apply H4 with t = t.
    apply is_list_inst to H3. apply H6 with t = t. search.
  apply is_fm_inst to H2. apply H4 with t = t.
    apply IH to H3. apply H6 with t = t. search. 

% Corollary:
% adj J (A x) (K x) -> adj J (A t) (K t)

Theorem merge_inst : forall J K L,
  nabla (x : term), merge (J x) (K x) (L x) -> forall t, merge (J t) (K t) (L t).
induction on 1. intros. case H1.
  search.
  apply adj_inst to H2. apply *H5 with t = t.
    apply adj_inst to H3. apply *H7 with t = t.
    apply IH to H4. apply *H9 with t = t.
    search.
  apply adj_inst to H2. apply *H5 with t = t.
    apply adj_inst to H3. apply *H7 with t = t.
    apply IH to H4. apply *H9 with t = t.
    search.

%% FOCUSED FIRST-ORDER MALL

% Two contexts are used to delay the application of synchronous rules
% (if only one context is used, we needed to reason on all formulas of
% the context before starting a focused phase).

% The working context can be processed in order during the async phase.

% By convention, all atoms have positive polarity (because of the way dual is defined).

Define 
  mall : olist -> olist -> prop,
  mallfoc : olist -> o -> prop
by
% Identity
; mallfoc (form (natom A) :: nil) (form (atom A))
% Decide
; mall G nil :=
    exists GG P, is_pos P /\ adj GG P G /\ mallfoc GG P
% Release
; mallfoc G F :=
    is_neg_or_atom F /\ mall G (F :: nil)
% Store
; mall G (F :: L) :=
    exists GF, is_pos_or_atom F /\ adj G F GF /\ mall GF L
% ASYNCHRONOUS PHASE
; mall G (form bot :: L) :=
    mall G L
; mall G (form (par A B) :: L) :=
    mall G (form A :: form B :: L)
; mall G (form top :: L)
; mall G (form (wth A B) :: L) :=
    mall G (form A :: L) /\ mall G (form B :: L)
; mall G (form (all A) :: L) :=
    nabla x, mall G (form (A x) :: L)
% SYNCHRONOUS PHASE
; mallfoc G (form one)
; mallfoc G (form (tens A B)) :=
    exists G1 G2, merge G1 G2 G /\ mallfoc G1 (form A) /\ mallfoc G2 (form B)
; mallfoc G (form (plus A B)) :=
    mallfoc G (form A)
; mallfoc G (form (plus A B)) :=
    mallfoc G (form B)
; mallfoc G (form (exs A)) :=
    exists x, mallfoc G (form (A x))
.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem generalized_id : forall A B,
  { dual A B } -> mall (form A :: nil) (form B :: nil).
induction on 1. intros. case H1.
  unfold 4. witness (form (natom A1) :: form (atom A1) :: nil). split.
    search.
    search.
    unfold 2. witness (form (natom A1) :: nil). witness (form (atom A1)). search.
  apply IH to H2. apply IH to H3. unfold 6. %% CANNOT STORE :(
    skip.
skip.
skip.
skip.
skip.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
