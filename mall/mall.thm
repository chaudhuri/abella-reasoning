Set instantiations on.
Set witnesses on.
Set subgoals off.
   
% MALL
Type a, b, c                   o.
Type tensor, par, plus, with   o -> o -> o.
Type one, bot, zero, top       o.
Type not                       o -> o.

Define atom : o -> prop by
  atom a ;
  atom b.

Define dual : o -> o -> prop by
  dual one bot ;
  dual bot one ;
  dual top zero ;
  dual zero top ;
  dual A (not A) := atom A;
  dual (not A) A := atom A;
  dual (tensor A B) (par C D) := dual A C /\ dual B D;
  dual (par A B) (tensor C D) := dual A C /\ dual B D;
  dual (plus A B) (with C D)  := dual A C /\ dual B D;
  dual (with A B) (plus C D)  := dual A C /\ dual B D.
  
Define split : olist -> olist -> olist -> prop by
  split nil nil nil ;
  split (X :: L3) (X :: L2) L1 := split L3 L2 L1 ;
  split (X :: L3) L2 (X :: L1) := split L3 L2 L1.

Define perm : olist -> olist -> prop by
  perm nil nil ;
  perm (X :: L2) (X :: L1) := perm L2 L1.

Define prove : olist -> prop by
  prove (one :: nil) ;                                                                                     % oneR
  prove (top :: Delta) ;                                                                                   % topR
  prove (A :: (not A) :: nil) := atom A;                                                                   % init
  prove (bot :: Delta) := prove Delta ;                                                                    % botR
  prove ((tensor A B) :: Delta) := exists D1 D2, split Delta D1 D2 /\ prove (A :: D1) /\ prove (B :: D2) ; % tensorR
  prove ((par A B) :: Delta) := prove (A :: B :: Delta) ;                                                  % parR
  prove ((with A B) :: Delta) := prove (A :: Delta) /\ prove (B :: Delta) ;                                % withR
  prove ((plus A B) :: Delta) := prove (A :: Delta) \/ prove (B :: Delta).                                 % plusR

Theorem split1_implies_perm : forall D2 D1,
  split D2 nil D1 -> perm D2 D1.

induction on 1. intros.
  case H1. search.
    apply IH to H2. unfold.
        search.

Theorem split2_implies_perm : forall D2 D1,
  split D2 D1 nil -> perm D2 D1.

induction on 1. intros.
  case H1. search.
    apply IH to H2. unfold.
        search.
  
Theorem atomic_inference : forall A B,
  atom A -> dual A B -> B = (not A).

intros.
  case H1.
    case H2.
      search.
    case H2.
      search.

Theorem split_of_perm : forall D3 D3' D2 D1,
  split D3 D2 D1 -> perm D3' D3 -> split D3' D2 D1.

induction on 2. intros.
  case H2.
    search.
  case H1.
    apply IH to H4 H3.
      search.
    apply IH to H4 H3.
      search.

Theorem perm_supercase1 : forall A B D D',
  prove (A :: B :: D) -> perm D' D -> perm (A :: B :: D') (A :: B :: D).

search.

Theorem perm_supercase2 : forall A D D',
  prove (A :: D) -> perm D' D -> perm (A :: D') (A :: D).

search.
  
Theorem perm_provability : forall D2 D1,
  prove D2 -> perm D1 D2 -> prove D1.

induction on 1. intros.
  case H1.
    case H2. case H3.
      search.
    case H2. case H3.
      search.
        search.
    case H2. case H4. case H5.
      search.
    case H2. apply IH to H3 H4.
      search.
    case H2.
      unfold. witness D3. witness D4.
        split. apply split_of_perm to H3 H6.
          search. search. search.
    case H2.
      unfold. apply perm_supercase1 to H3 H4.
        apply IH to H3 H5.
          search.
    case H2. unfold.
      apply perm_supercase2 to H3 H5.
        apply IH to H3 H6.
          search.
      apply perm_supercase2 to H4 H5.
        apply IH to H4 H6.
          search.
    case H2. unfold.
      case H3.
        apply perm_supercase2 to H5 H4.
          apply IH to H5 H6.
            search.
        apply perm_supercase2 to H5 H4.
          apply IH to H5 H6.
            search.

Theorem despise_order_atomic_case : forall A,
  prove (not A :: not (not A) :: nil) -> prove (A :: (not A) :: nil). 

Theorem cut_admissibility : forall B C D D1 D2,
    prove (B :: D1) -> prove (C :: D2) -> dual B C -> split D D1 D2 -> prove D.

induction on 1. induction on 2. intros.
  case H1 (keep). % left premise
    % B = one
    case H2 (keep). % right premise
      case H3. case H3. % trivial
        case H3. % init
          case H5. case H5.
        % C = bot
        apply split1_implies_perm to H4.
          apply perm_provability to H5 H6.
            search.
      case H3. case H3. case H3. case H3. % trivial
    % B = top
    case H2 (keep).
      case H3. case H3.
        case H3. % init
          case H5. case H6.
        case H3. case H3. case H3. case H3. case H3.
    % atom (B)
    case H2 (keep).
      case H3.
        case H5. case H6.
      case H3.
        case H5. case H6.
      case H3.
        case H5. case H5. case H5. case H5. % trivial
        case H4. case H8. case H9.
        % Abella shows a hypothesis H: atom (not B). We can not eliminate the case applying case analysis on H, because this is just
        % an implementation subtlety. (atom (not B)) should be viewed as (not (atom B)). Is it really a subtlety or a mistake? Think about it.
        