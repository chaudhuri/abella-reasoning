Type is_o  o -> prop.

Import "perm" with is_o := is_o.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% merge J K L : J union K equals L.
Define merge : olist -> olist -> olist -> prop by
; merge nil nil nil
; merge J K L :=
    exists A JJ LL,
      adj JJ A J /\ adj LL A L /\ merge JJ K LL
; merge J K L :=
    exists A KK LL,
      adj KK A K /\ adj LL A L /\ merge J KK LL
.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem merge_1_is_list : forall J K L, merge J K L -> is_list J.
induction on 1. intros. case H1.
  search.
  backchain adj_3_is_list.
  backchain IH.

Theorem merge_2_is_list : forall J K L, merge J K L -> is_list K.
induction on 1. intros. case H1.
  search.
  backchain IH.
  backchain adj_3_is_list.

Theorem merge_3_is_list : forall J K L, merge J K L -> is_list L.
intros. case H1.
  search.
  backchain adj_3_is_list.
  backchain adj_3_is_list.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem perm_merge_1 : forall J K L JJ,
  merge J K L ->
  perm J JJ ->
  merge JJ K L.
induction on 1. intros. case H1.
  case H2. search. case H3.
  apply adj_perm to H2 H3.
   apply perm_invert to H2 H3 H6.
   apply IH to H5 H7. search.
  apply IH to H5 H2. search.

Theorem perm_merge_2 : forall J K L KK,
  merge J K L ->
  perm K KK ->
  merge J KK L.
induction on 1. intros. case H1.
  case H2. search. case H3.
  apply IH to H5 H2. search.
  apply adj_perm to H2 H3.
   apply perm_invert to H2 H3 H6.
   apply IH to H5 H7. search.

Theorem perm_merge_3 : forall J K L LL,
  merge J K L ->
  perm L LL ->
  merge J K LL.
induction on 1. intros. case H1.
  case H2. search. case H3.
  apply adj_perm_result to H2 H4.
   apply IH to H5 H7. search.
  apply adj_perm_result to H2 H4.
   apply IH to H5 H7. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem merge_sym : forall J K L,
  merge J K L ->
  merge K J L.
induction on 1. intros. case H1.
  search.
  apply IH to H4. search.
  apply IH to H4. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem merge_move_12 : forall A JJ J KK K L,
  adj JJ A J ->
  adj KK A K ->
  merge J KK L ->
  merge JJ K L.
induction on 3. intros. case H3.
  case H1.
  apply adj_same_result_diff to H4 H1. case H7.
    apply perm_merge_1 to H6 H8. search.
    apply adj_swap to H8 H1. apply adj_same_result to H10 H4.
     apply adj_perm to H11 H9.
     apply adj_swap to H12 H4. apply adj_same_result to H14 H1.
     apply IH to H12 H2 H6.
     assert merge U1 K L. backchain perm_merge_1.
  apply adj_swap to H4 H2.
   apply IH to H1 H7 H6. search.

Theorem merge_invert_1 : forall A JJ J K LL L,
  merge J K L ->
  adj JJ A J ->
  adj LL A L ->
  merge JJ K LL.
induction on 1. intros. case H1.
  % nil case is impossible since J is non-empty
  case H2.

  % J = A1 + JJ1, L = A1 + LL1
  apply adj_same_result_diff to H4 H2. case H7.

    % A1 = A, in which case JJ ~ JJ1
    apply adj_same_result to *H5 *H3.
     apply perm_merge_1 to *H6 *H8.
     backchain perm_merge_3.

    % A1 = A not known, in which case, for some KK, JJ = A1 + KK
    apply adj_swap to H8 H2.
     apply adj_same_result to H4 H10.
     apply adj_same_result_diff to H3 H5. case H12.

      % A1 = A and LL ~ LL1
      apply adj_same_result to H10 H2.
       apply perm_trans to H11 H14.
       apply perm_merge_1 to H6 H15.
       apply perm_sym to H13.
       backchain perm_merge_3.

      % A1 = A not known, but LL1 = A + KK1
      apply perm_sym to H11.
       apply adj_perm to H14 H9.
       apply IH to H6 H15 H13.
       apply adj_swap to H13 H5.
       apply adj_same_result to H18 H3.
       backchain perm_merge_3.
       assert merge KK K KK1.
         assert perm KK2 KK.
           backchain perm_invert.
           backchain perm_merge_1.
       search.

  % K = A1 + KK1, L = A1 + LL1
  apply adj_same_result_diff to H5 H3. case H7.

    % A = A1, LL1 ~ LL
    apply perm_merge_3 to *H6 *H8.
     backchain merge_move_12.

    % A = A1 not known, LL = KK1 + A1
    rename KK1 to LLL.
     apply adj_swap to H8 H3.
     apply adj_same_result to H10 H5.
     apply adj_perm to H11 H9.
     apply IH to H6 H2 H12.
     apply adj_swap to H12 H5.
     assert merge JJ K U1.
     apply adj_same_result to H15 H3.
     backchain perm_merge_3.

Theorem merge_move_21 : forall A JJ J KK K L,
  adj JJ A J ->
  adj KK A K ->
  merge JJ K L ->
  merge J KK L.
intros. apply merge_sym to *H3.
apply merge_move_12 to *H2 *H1 *H4.
backchain merge_sym.

Theorem merge_invert_2 : forall A J KK K LL L,
  merge J K L ->
  adj KK A K ->
  adj LL A L ->
  merge J KK LL.
intros. apply merge_sym to *H1.
apply merge_invert_1 to *H4 *H2 *H3.
backchain merge_sym.

Theorem merge_nil_perm : forall K L,
  merge nil K L -> perm K L.
induction on 1. intros. case H1.
  search.
  case H2.
  apply IH to H4. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem merge_unadj_1 : forall J K L JJ A,
  merge J K L -> adj JJ A J -> exists LL, adj LL A L /\ merge JJ K LL.
induction on 1. intros. case H1.
  case H2.
  apply adj_same_result_diff to H2 H3. case H6.
    apply perm_sym to *H7. apply perm_merge_1 to *H5 *H8. search.
    apply IH to *H5 H7. apply adj_swap to H8 H4. apply adj_swap to H7 H3.
     assert merge U1 K U. apply adj_same_result to H13 H2.
     apply perm_merge_1 to *H14 *H15. search.
  apply IH to H5 H2. apply adj_swap to H6 H4. assert merge JJ K U. search.

Theorem merge_unadj_2 : forall J K L KK A,
  merge J K L -> adj KK A K -> exists LL, adj LL A L /\ merge J KK LL.
intros. apply merge_sym to *H1. apply merge_unadj_1 to *H3 *H2.
 apply merge_sym to *H5. search.

Theorem merge_unadj_3 : forall J K L LL A,
  merge J K L -> adj LL A L ->
  (exists JJ, adj JJ A J /\ merge JJ K LL)
  \/ (exists KK, adj KK A K /\ merge J KK LL).
induction on 1. intros. case H1.
  case H2.

  apply adj_same_result_diff to H4 H2. case H6.
    apply perm_merge_3 to *H5 *H7. search.
    apply adj_swap to H7 H2. apply adj_same_result to H9 H4.
     apply adj_perm to H10 H8. apply IH to H5 H11. case H12.
       apply adj_swap to H13 H3.
        assert merge U1 K LL.
          apply adj_swap to H11 H4.
          apply adj_same_result to H18 H2.
          backchain perm_merge_3.
        search.
       apply adj_swap to H11 H4.
        assert merge J KK2 U1.
        apply adj_same_result to H16 H2. apply perm_merge_3 to *H17 *H18.
        search.

  apply adj_same_result_diff to H4 H2. case H6.
    apply perm_merge_3 to *H5 *H7. search.
    apply adj_swap to H7 H2. apply adj_same_result to H9 H4.
     apply adj_perm to H10 H8. apply IH to H5 H11. case H12.
       apply adj_swap to H11 H4.
        assert merge JJ K U1.
        apply adj_same_result to H16 H2. apply perm_merge_3 to *H17 *H18.
        search.
       apply adj_swap to H13 H3.
        assert merge J U1 LL.
          apply adj_swap to H11 H4.
          apply adj_same_result to H18 H2.
          backchain perm_merge_3.
        search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem add_to_merge_right : forall A J K KK L,
  adj KK A K ->
  merge J KK L ->
  exists M, merge J K M /\ adj L A M.
intros.
  apply adj_2_is_o to H1.
  apply merge_3_is_list to H2.
  apply adj_exists to H3 H4. search.

Theorem add_to_merge_left : forall A J JJ K L,
  adj JJ A J ->
  merge JJ K L ->
  exists M, merge J K M /\ adj L A M.
intros.
  apply adj_2_is_o to H1.
  apply merge_3_is_list to H2.
  apply adj_exists to H3 H4. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem merge_nil_equal : forall L,
  is_list L -> merge nil L L.
induction on 1. intros. case H1.
  search.
  apply IH to H3. search.

Theorem merge_exists : forall J K,
  is_list J -> is_list K ->
  exists L, merge J K L.
induction on 1. intros. case H1.
  apply merge_nil_equal to H2. search.
  apply IH to H4 H2. assert (adj L A (A :: L)).
    apply add_to_merge_left to H6 H5. search.
