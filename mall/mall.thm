Set instantiations on.
Set witnesses on.
Set subgoals off.
   
% MALL
Type a, b, c                   o.
Type tensor, par, plus, with   o -> o -> o.
Type one, bot, zero, top       o.
Type not                       o -> o.

Define atom : o -> prop by
  atom a ;
  atom b.

Define dual : o -> o -> prop by
  dual one bot ;
  dual bot one ;
  dual top zero ;
  dual zero top ;
  dual A (not A) := atom A;
  dual (not A) A := atom A; % can we remove this? maybe it will be useful
  dual (tensor A B) (par C D) := dual A C /\ dual B D;
  dual (par A B) (tensor C D) := dual A C /\ dual B D;
  dual (plus A B) (with C D)  := dual A C /\ dual B D;
  dual (with A B) (plus C D)  := dual A C /\ dual B D.
  
Define split : olist -> olist -> olist -> prop by
  split nil nil nil ;
  split (X :: L3) (X :: L2) L1 := split L3 L2 L1 ;
  split (X :: L3) L2 (X :: L1) := split L3 L2 L1.

Define perm : olist -> olist -> prop by
  perm nil nil ;
  perm (X :: L2) (X :: L1) := perm L2 L1.

Define is_list : olist -> prop by
  is_list nil ;
  is_list (X :: L) := is_list L.

Define fm : o -> prop by
  fm one ;
  fm bot ;
  fm zero ;
  fm top ;
  fm (A) := atom A ;
  fm (tensor A B) := form A /\ form B ;
  fm (par A B) := form A /\ form B ;
  fm (plus A B) := form A /\ form B ;
  fm (with A B) := form A /\ form B.

Define prove : olist -> prop by
  prove (one :: nil) ;                                                                                     % oneR
  prove (top :: Delta) ;                                                                                   % topR
  prove (A :: (not A) :: nil) := atom A;                                                                   % init
  prove (bot :: Delta) := prove Delta ;                                                                    % botR
  prove ((tensor A B) :: Delta) := exists D1 D2, split Delta D1 D2 /\ prove (A :: D1) /\ prove (B :: D2) ; % tensorR
  prove ((par A B) :: Delta) := prove (A :: B :: Delta) ;                                                  % parR
  prove ((with A B) :: Delta) := prove (A :: Delta) /\ prove (B :: Delta) ;                                % withR
  prove ((plus A B) :: Delta) := prove (A :: Delta) \/ prove (B :: Delta).                                 % plusR

% Theorem double_negation_axiom : forall A,
%   prove ((not A) :: (not (not A)) :: nil) -> prove (A :: (not A) :: nil).

% skip.

Theorem split1_implies_perm : forall D2 D1,
  split D2 nil D1 -> perm D2 D1.

induction on 1. intros.
  case H1. search.
    apply IH to H2. unfold.
        search.

Theorem split2_implies_perm : forall D2 D1,
  split D2 D1 nil -> perm D2 D1.

induction on 1. intros.
  case H1. search.
    apply IH to H2. unfold.
        search.
  
Theorem atomic_inference : forall A B,
  atom A -> dual A B -> B = (not A).

intros.
  case H1.
    case H2.
      search.
    case H2.
      search.

Theorem split_of_perm : forall D3 D3' D2 D1,
  split D3 D2 D1 -> perm D3' D3 -> split D3' D2 D1.

induction on 2. intros.
  case H2.
    search.
  case H1.
    apply IH to H4 H3.
      search.
    apply IH to H4 H3.
      search.

Theorem perm_supercase1 : forall A B D D',
  prove (A :: B :: D) -> perm D' D -> perm (A :: B :: D') (A :: B :: D).

search.

Theorem perm_supercase2 : forall A D D',
  prove (A :: D) -> perm D' D -> perm (A :: D') (A :: D).

search.
  
Theorem perm_provability : forall D2 D1,
  prove D2 -> perm D1 D2 -> prove D1.

induction on 1. intros.
  case H1.
    case H2. case H3.
      search.
    case H2. case H3.
      search.
        search.
    case H2. case H4. case H5.
      search.
    case H2. apply IH to H3 H4.
      search.
    case H2.
      unfold. witness D3. witness D4.
        split. apply split_of_perm to H3 H6.
          search. search. search.
    case H2.
      unfold. apply perm_supercase1 to H3 H4.
        apply IH to H3 H5.
          search.
    case H2. unfold.
      apply perm_supercase2 to H3 H5.
        apply IH to H3 H6.
          search.
      apply perm_supercase2 to H4 H5.
        apply IH to H4 H6.
          search.
    case H2. unfold.
      case H3.
        apply perm_supercase2 to H5 H4.
          apply IH to H5 H6.
            search.
        apply perm_supercase2 to H5 H4.
          apply IH to H5 H6.
            search.

Theorem split_implies_list1 : forall L R S,
  split L R S -> is_list S.

induction on 1. intros.
  case H1. search.
    apply IH to H2. search.
      apply IH to H2. search.

Theorem split_existence : forall R S,
  is_list R -> is_list S -> exists L, split L R S.

induction on 1. induction on 2. intros.
  case H1 (keep).
    case H2 (keep).
      search.
    apply IH1 to H1 H3.
      search.
    apply IH to H3 H2.
      search.

Theorem split_plus_form1 : forall A B D D1 D2,
  prove (A :: B :: D2) -> split D D1 D2 -> split (B :: D) D1 (B :: D2).

intros. search.

Theorem split_plus_form2 : forall A B D D1 D2,
  prove (A :: B :: D2) -> split D D1 D2 -> split (A :: D) D1 (A :: D2).

intros. search.

Theorem rename_ms_with_form1 : forall A B D D1 D2,
  prove (A :: B :: D2) -> split (B :: D) D1 (B :: D2) -> exists D', prove (A :: D') /\ split (B :: D) D1 D'.

intros. search.

% Theorem rename_ms_with_form2 : forall A B D D1 D2,
%   prove (A :: B :: D2) -> split (A :: D) D1 (A :: D2) -> exists D', prove (B :: D') /\ split (A :: D) D1 D'.

% intros. search.
  
% Theorem split_redistribution : forall D D1 D2 D3 D4 D5,
%  split D D1 D2 -> split D1 D3 D4 -> split D5 D2 D4 -> split D D3 D5.

% Theorem despise_order : forall A B D,
%   fm A -> fm B -> prove (A :: B :: D) -> prove (B :: A :: D).

Theorem cut_admissibility : forall B C D D1 D2,
    prove (B :: D1) -> prove (C :: D2) -> dual B C -> split D D1 D2 -> prove D.

induction on 1. induction on 2. intros.
  case H1 (keep). % left premise
    % B = one
    case H2 (keep). % right premise
      case H3. case H3. % trivial
        case H3. % init
          case H5. case H5.
        % C = bot
        apply split1_implies_perm to H4.
          apply perm_provability to H5 H6.
            search.
      case H3. case H3. case H3. case H3. % trivial
    % B = top
    case H2 (keep).
      case H3. case H3.
        case H3. % init
          case H5. case H6.
        case H3. case H3. case H3. case H3. case H3.
    % B = atom (B)
    case H2 (keep).
      case H3.
        case H5. case H6.
      case H3.
        case H5. case H6.
      case H3.
        case H5. case H5. case H5. case H5. % trivial
        case H6. case H5. % Remove this later, it's not correct
        %case H4. case H8. case H9.
        % Abella shows a hypothesis H: atom (not B). We can not eliminate the case applying case analysis on H, because this is just
        % an implementation subtlety. (atom (not B)) should be viewed as (not (atom B)). Is it really a subtlety or a mistake? Think about it.
        case H5. case H5. case H5. case H5. % trivial
      case H3. % trivial
        case H5. case H7.
      case H3. % trivial
        case H9. case H5.
      case H3. % trivial
        case H7. case H5.
      case H3. % trivial
        case H8. case H5.
      case H3. % trivial
        case H7. case H5.
    % B = bot
    case H2 (keep).
      apply split2_implies_perm to H4.
        apply perm_provability to H5 H6.
          search.
      case H3. case H3.
        case H6. case H7.
      case H3. case H3. case H3.
      case H3. case H3.
    % B = tensor A B1
    case H2 (keep).
      case H3. case H3. case H3.
        case H9. case H8.
      case H3.
        case H3. % trivial
      case H3.
        % apply split_implies_list1 to H4.
        %   apply split_implies_list1 to H5.
        %     apply split_existence to H12 H11.
        %       apply split_plus_form2 to H8 H13.
        %         apply rename_ms_with_form2 to H8 H14.
        %           apply IH to H7 H15 H10 H16.