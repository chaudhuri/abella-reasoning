%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                    %%
%%       MALL specification in        %%
%%       Abella (.thm)                %%
%%                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% More verbose output
Set instantiations on.
Set witnesses on.
Set subgoals off.

Type a, b, c, d                o.
Type tensor, par, plus, with   o -> o -> o.
Type one, bot, zero, top       o.
Type not, atom                 o -> o.

Define formula : o -> prop by
  formula (tensor A B) := formula A /\ formula B ;
  formula (plus A B) := formula A /\ formula B ;
  formula (with A B) := formula A /\ formula B ;
  formula (par A B) := formula A /\ formula B ;
  formula (zero) ; 
  formula (one) ; 
  formula (bot) ;
  formula (top) ; 
  formula (atom A).

Import "../lib/merge" with is_o := formula.

Define prove : olist -> olist -> prop by
  % 1. Identity
  prove G D := exists A, adj nil (atom A) G /\ adj nil (atom A) D ;

  % Multiplicative rules
  % 2. oneR
  prove G D := G = nil /\ adj nil one D ;
  % 3. oneL
  prove G D := exists G', adj G' one G /\ prove G' D ;
  % 4. tensorL
  prove G D := exists A B G' G1 G2, 
    adj G' (tensor A B) G /\ adj G2 A G1 /\ adj G' B G2 /\ prove G1 D ;
  % 5. tensorR
  prove G D := exists A B D' D1 D2 D1' D2' G1 G2, 
    adj D' (tensor A B) D /\ merge D1' D2' D' /\ merge G1 G2 G /\ 
    adj D1' A D1 /\ adj D2' B D2 /\ prove G1 D1 /\ prove G2 D2 ;
  % 6. botL
  prove G D := D = nil /\ adj nil bot G ;
  % 7. botR
  prove G D := exists D', adj D' bot D /\ prove G D' ;
  % 8. parR
  prove G D := exists A B D' D1 D2, 
    adj D' (par A B) D /\ adj D1 A D' /\ adj D2 B D1 /\ prove G D' ;
  % 9. parL
  prove G D := exists A B G' G1 G2 G1' G2' D1 D2, 
    adj G' (par A B) G /\ merge G1 G2 G' /\ merge D1 D2 D /\ adj G1' A G1 /\ 
    adj G2' B G2 /\ prove G1 D1 /\ prove G2 D2 ;

  % Additive rules
  % 10. zeroL
  prove G D := exists G', adj G' zero G ;
  % 11. topR
  prove G D := exists D', adj D' top D ;
  % 12. withL1
  prove G D := exists A B G' G1, 
    adj G' (with A B) G /\ adj G1 A G' /\ prove G' D ;
  % 13. withL2
  prove G D := exists A B G' G1, 
    adj G' (with A B) G /\ adj G1 B G' /\ prove G' D ;
  % 14. withR
  prove G D := exists A B D' D1 D2, 
    adj D' (with A B) D /\ adj D' A D1 /\ adj D' B D2 /\ prove G D1 /\ prove G D2 ;
  % 15. plusR1
  prove G D := exists A B D' D1, 
    adj D' (plus A B) D /\ adj D1 A D' /\ prove G D' ;
  % 16. plusR2
  prove G D := exists A B D' D1, 
    adj D' (plus A B) D /\ adj D1 B D' /\ prove G D' ;
  % 17. plusL
  prove G D := exists A B G' G1 G2, 
    adj G' (plus A B) G /\ adj G' A G1 /\ adj G' B G2 /\ prove G1 D /\ prove G2 D.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Reasoning

Theorem cut_admissibility : forall C G1 D1 D1' G2 G2' D2,
  formula C ->
  prove G1 D1 -> prove G2 D2 ->
  adj D1' C D1 -> adj G2' C G2 ->
  exists G3 D3,
  merge G2' G1 G3 /\ merge D2 D1' D3 /\ 
  prove G3 D3.

induction on 1. induction on 2. induction on 3. intros.

% Tensor case
case H1 (keep).
  % Unfolds the induction on the left premise (cut-formula in the succedent)
  % Each case is a possible rule applied to the left premise.
  case H2 (keep).

    % init case -- invalid (contexts need to be empty)
   case H9. case H4. case H13.

    % oneR case -- invalid (contexts need to be empty)
    case H8. case H4. case H12.

    % oneL case -- permutes down
    apply IH1 to H1 H9 H3 H4 H5.
    apply add_to_merge_right to H8 H10.
    search.

    % tensorL case -- permutes down
    apply IH1 to H1 H11 H3 H4 H5.
    apply merge_unadj_2 to H12 H9.
    apply merge_unadj_2 to H16 H10.
    apply add_to_merge_right to H8 H18.
    search.

    % tensorR case -- principal or permutes down
    apply adj_same_result_diff to H4 H8.
    case H15.
      % 1. the cut-formula is principal
      % Unfolds the right premise (cut-formula in the antecedent)
      % Each case is a possible rule applied to the right premise
      case H3 (keep).

        % init case -- invalid (context needs to be empty)
        case H17. case H5. case H22.

        % oneR case -- invalid (context needs to be empty)
        case H5.

        % oneL case -- permutes down
        apply adj_same_result_diff to H5 H17. case H19.
        apply IH2 to H1 H2 H18 H4 H20.
        apply adj_swap to H20 H17.
        apply add_to_merge_left to H24 H21.
        apply adj_same_result to H5 H25. apply perm_sym to H28.
        apply perm_merge_1 to H26 H29.
        search.

        % tensorL case -- principal or permutes down
        apply adj_same_result_diff to H5 H17.
        case H21.
          % 1. the cut formula is principal -- reduce complexity.
          apply IH to H6 H13 H20 H11 H18. % cut on A
          apply merge_unadj_1 to H23 H19.
          apply IH to H7 H14 H25 H12 H26. % cut on B
          exists G8. exists D6.
          split.
            % merge antecedents
            apply change_merge_order to H28 H27 H10.
            apply perm_sym to H22. apply perm_sym to H31.
            apply perm_merge_1 to H32 H33.
            apply perm_merge_3 to H35 H34.
            search.

            % merge succedents
            apply change_merge_order to H29 H24 H9.
            apply perm_sym to H16. apply perm_sym to H31.
            apply perm_merge_2 to H32 H33.
            apply perm_merge_3 to H35 H34.
            search.

            % prove conclusion.
            search.

          % 2. the tensorL is applied to another formula -- permutes down
          skip.

        % tensorR case
        skip.

        % botL case
        skip.

        % botR case
        skip.

        % parR case
        skip.
   
        % parL case
        skip.
   
        % zeroL case
        skip.
   
        % topR case
        skip.
   
        % withL1 case
        skip.
   
        % withL2 case
        skip.
   
        % withR case
        skip.
   
        % plusR1 case
        skip.
   
        % plusR2 case
        skip.
   
        % plusL case
        skip.

      % 2. the tensorR is applied to another formula -- permutes down
      apply merge_unadj_3 to H9 H16.
      case H17.
        % 1. Cut-formula goes to the left premise of tensorR.
        apply adj_swap to H18 H11.
        apply IH1 to H1 H13 H3 H21 H5. 
        apply merge_unadj_2 to H23 H20.
        apply merge_3_is_list to H26. apply merge_2_is_list to H9.
        apply merge_exists to H27 H28.
        apply merge_3_is_list to H29. apply adj_2_is_o to H8.
        apply adj_exists to H31 H30.
        apply merge_2_is_list to H10. apply merge_3_is_list to H22.
        apply merge_exists to H33 H34.
        apply merge_sym to H35.
        exists L1. exists M.
        split.
          % merge of antecedents
          apply merge_1_is_list to H22. apply merge_3_is_list to H10.
          apply merge_exists to H37 H38.
          apply merge_assoc to H22 H10 H39 H36.
          % TODO use change_merge_order
          apply perm_merge_3 to H39 H40. search. 

          % merge of succeedents
          apply merge_1_is_list to H23. apply merge_3_is_list to H19.
          apply merge_exists to H37 H38.
          apply merge_assoc to H26 H19 H39 H29. 
          % TODO use change_merge_order
          apply merge_3_is_list to H39.
          apply adj_exists to H31 H41.
          apply adj_preserves_perm to H42 H32 H40.
          apply adj_implies_merge to H42.
          apply adj_implies_merge to H16. 
          apply adj_implies_merge to H8. 
          apply adj_implies_merge to H4.
          apply merge_sub to H45 H46 H47.
          apply merge_1_is_list to H39.
          apply adj_1_is_list to H4.
          apply merge_exists to H49 H50.
          apply merge_assoc to H39 H48 H51 H44. 
          apply perm_merge_3 to H51 H52.
          apply perm_merge_3 to H53 H43.
          search.

          % provability of conclusion
          unfold 5. search.

        % 2. Cut-formula goes to the right premise of tensorR.
        apply adj_swap to H18 H12.
        apply IH1 to H1 H14 H3 H21 H5.
        apply merge_unadj_2 to H23 H20.
        apply merge_3_is_list to H26. apply merge_1_is_list to H9.
        apply merge_exists to H28 H27.
        apply merge_3_is_list to H29. apply adj_2_is_o to H8.
        apply adj_exists to H31 H30.
        apply merge_1_is_list to H10. apply merge_3_is_list to H22.
        apply merge_exists to H33 H34.
        exists L1. exists M.
        split.
          % merge of antecedents
          apply merge_sym to H35.
          apply merge_1_is_list to H22. apply merge_3_is_list to H10.
          apply merge_exists to H37 H38.
          apply merge_sym to H10.
          apply merge_assoc to H22 H40 H39 H36.
          % TODO use change_merge_order
          apply perm_merge_3 to H39 H41. search. 

          % merge of succedents
          apply merge_1_is_list to H23. apply merge_3_is_list to H19.
          apply merge_exists to H36 H37.
          apply merge_sym to H19. apply merge_sym to H29.
          apply merge_assoc to H26 H39 H38 H40. 
          % TODO use change_merge_order
          apply merge_3_is_list to H38.
          apply adj_exists to H31 H42.
          apply adj_preserves_perm to H43 H32 H41.
          apply adj_implies_merge to H16. 
          apply adj_implies_merge to H8. 
          apply adj_implies_merge to H4.
          apply merge_sub to H45 H46 H47.
          apply merge_1_is_list to H38.
          apply adj_1_is_list to H4.
          apply merge_exists to H49 H50.
          apply adj_implies_merge to H43.
          apply merge_assoc to H38 H48 H51 H52. 
          apply perm_sym to H44. apply perm_sym to H53.
          apply perm_trans to H54 H55.
          apply perm_sym to H56.
          apply perm_merge_3 to H51 H57.
          search.

          % provability of conclusion
          unfold 5. search.

    % botL case -- invalid (contexts need to be empty)
    case H4.

    % botR case -- permutes down
    apply adj_same_result_diff to H4 H8.
    case H10.
    apply IH1 to H1 H9 H3 H11 H5.
    apply adj_swap to H11 H8.
    apply adj_same_result to H4 H16.
    apply add_to_merge_right to H15 H13.
    exists G3. exists M. split.
      search.
      apply perm_sym to H17. apply perm_merge_2 to H18 H20. search. 
      search.
    
    % parR case
    skip.

    % parL case
    skip.

    % zeroL case
    skip.

    % topR case
    skip.

    % withL1 case
    skip.

    % withL2 case
    skip.

    % withR case
    skip.

    % plusR1 case
    skip.

    % plusR2 case
    skip.

    % plusL case
    skip.

