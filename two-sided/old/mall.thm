%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                    %%
%%       MALL specification in        %%
%%       Abella (.thm)                %%
%%                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Multisets

Define is_list : olist -> prop by
  is_list nil ;
  is_list (X :: L) := is_list L.

Define split : olist -> olist -> olist -> prop by
  split nil nil nil ;
  split (X :: L3) L2 (X :: L1) := split L3 L2 L1 ;
  split (X :: L3) (X :: L2) L1 := split L3 L2 L1.

Define memb_and_rest : o -> olist -> olist -> prop by
  memb_and_rest X (X :: L) L := is_list L ;
  memb_and_rest X (Y :: L) (Y :: R) := memb_and_rest X L R.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% MALL

Type a, b, c, d                o.
Type tensor, par, plus, with   o -> o -> o.
Type one, bot, zero, top       o.
Type not, atom                 o -> o.

Define formula : o -> prop by
  formula (tensor A B) := formula A /\ formula B ;
  formula (plus A B) := formula A /\ formula B ;
  formula (with A B) := formula A /\ formula B ;
  formula (par A B) := formula A /\ formula B ;
  formula (zero) ; 
  formula (one) ; 
  formula (bot) ;
  formula (top) ; 
  formula (atom A).

Define prove : olist -> olist -> prop by
  % Identity rules
  prove G D := exists A, memb_and_rest (atom A) G nil /\ memb_and_rest (atom A) D nil ;                     % init

  % Multiplicative rules
  prove G D := G = nil /\ memb_and_rest one D nil ;                                                         % oneR
  prove G D := exists G', memb_and_rest one G G' /\ prove G' D ;                                            % oneL
  prove G D := exists A B G' G1 G2, memb_and_rest (tensor A B) G G' /\ memb_and_rest A G1 G2 /\
               memb_and_rest B G2 G' /\ prove G1 D ;                                                        % tensorL
  prove G D := exists A B D' D1 D2 D1' D2' G1 G2, memb_and_rest (tensor A B) D D' /\ split D' D1' D2' /\
               split G G1 G2 /\ memb_and_rest A D1 D1' /\ memb_and_rest B D2 D2' /\ prove G1 D1 /\
               prove G2 D2 ;                                                                                % tensorR
  prove G D := D = nil /\ memb_and_rest bot G nil ;                                                         % botL
  prove G D := exists D', memb_and_rest bot D D' /\ prove G D' ;                                            % botR
  prove G D := exists A B D' D1 D2, memb_and_rest (par A B) D D' /\ memb_and_rest A D' D1 /\
                                memb_and_rest B D1 D2 /\ prove G D' ;                                       % parR
  prove G D := exists A B G' G1 G2 G1' G2' D1 D2, memb_and_rest (par A B) G G' /\ split G' G1 G2 /\
               split D D1 D2 /\ memb_and_rest A G1 G1' /\ memb_and_rest B G2 G2' /\ prove G1 D1 /\
               prove G2 D2 ;                                                                                % parL

  % Additive rules
  prove G D := exists G', memb_and_rest zero G G' ;                                                         % zeroL
  prove G D := exists D', memb_and_rest top D D' ;                                                          % topR
  prove G D := exists A B G' G1, memb_and_rest (with A B) G G' /\ memb_and_rest A G' G1 /\
               prove G' D ;                                                                                 % withL1
  prove G D := exists A B G' G1, memb_and_rest (with A B) G G' /\ memb_and_rest B G' G1 /\
               prove G' D ;                                                                                 % withL2
  prove G D := exists A B D' D1 D2, memb_and_rest (with A B) D D' /\ memb_and_rest A D1 D' /\
               memb_and_rest B D2 D' /\ prove G D1 /\ prove G D2 ;                                          % withR
  prove G D := exists A B D' D1, memb_and_rest (plus A B) D D' /\ memb_and_rest A D' D1 /\
               prove G D' ;                                                                                 % plusR1
  prove G D := exists A B D' D1, memb_and_rest (plus A B) D D' /\ memb_and_rest B D' D1 /\
               prove G D' ;                                                                                 % plusR2
  prove G D := exists A B G' G1 G2, memb_and_rest (plus A B) G G' /\ memb_and_rest A G1 G' /\
               memb_and_rest B G2 G' /\ prove G1 D /\ prove G2 D.                                           % plusL

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Reasoning
% More verbose output
Set instantiations on.
Set witnesses on.
Set subgoals off.

% Hack theorem so that we get the predicates we need.
Theorem split_implies_list : forall L1 L2 L3,
  split L1 L2 L3 -> is_list L1 /\ is_list L3 /\ is_list L2.

induction on 1. intros.
case H1.
  search.
  apply IH to H2. search.
  apply IH to H2. search.

Theorem membrest_implies_list : forall F L1 L2,
  memb_and_rest F L1 L2 -> is_list L1 /\ is_list L2.

induction on 1. intros. case H1.
  search.
  apply IH to H2.
    search.

Theorem split_comm : forall L1 L2 L3,
  split L3 L2 L1 -> split L3 L1 L2.

induction on 1. intros. case H1.
  search.
  apply IH to H2.
    search.
  apply IH to H2.
    search.

Theorem split_exists : forall R S,
  is_list R -> is_list S -> exists L, split L R S.

induction on 1. induction on 2. intros.
  case H1 (keep).
    case H2 (keep).
      search.
    apply IH1 to H1 H3.
      search.
    apply IH to H3 H2.
      search.

%             L
%      |--------------|
% F :: [ L1 ] :: [ L2 ]
% |---------|
%     L1'
% |-------------------|
%          L'
%
Theorem add_to_split_left : forall L L1 L1' L2 F, 
  split L L1 L2 -> memb_and_rest F L1' L1 -> 
  exists L', 
  split L' L1' L2 /\ memb_and_rest F L' L.
  
induction on 1. intros.
case H1.
  exists L1'. split.
    case H2. search.
    search.
  apply IH to H3 H2. exists (X :: L'). search.
  case H2.
    exists (F :: (X :: L3)). split.
      search. unfold. apply split_implies_list to H3. search.
    apply IH to H3 H4. exists (X :: L'). search.
      
%        L
% |--------------|
% [ L1 ] :: [ L2 ] :: F
%           |---------|
%               L2'
% |-------------------|
%          L'
%
Theorem add_to_split_right : forall L L1 L2 L2' F, 
  split L L1 L2 -> memb_and_rest F L2' L2 -> 
  exists L', 
  split L' L1 L2' /\ memb_and_rest F L' L.

induction on 1. intros.
case H1.
  exists L2'. split.
    case H2. search.
    search.
  case H2.
    exists (F :: (X :: L3)). split.
      search.
      apply split_implies_list to H3. search.
    apply IH to H3 H4. exists (X :: L'). search.
  apply IH to H3 H2. exists (X :: L'). search.

%           L4
% |--------------------|
%      L3
% |----------|
%  F :: [ L1 ] :: [ L2 ]
%       |--------------|
%             L5
%
Theorem remove_from_split_left : forall F L1 L2 L3 L4,
  split L4 L3 L2 -> memb_and_rest F L3 L1 ->
  exists L5, split L5 L1 L2 /\ memb_and_rest F L4 L5.

induction on 1. intros.
  case H1. case H2.
  apply IH to H3 H2. witness (X :: L6).
    search.
  case H2.
    witness L5. split. 
      search.
      apply split_implies_list to H3. search.
    apply IH to H3 H4.
      witness (X :: L7). search.

%           L4
% |--------------------|
%      L3
% |----------|
%  F :: [ L2 ] :: [ L1 ]
%       |--------------|
%              L5
%
Theorem remove_from_split_right : forall F L1 L2 L3 L4,
  split L4 L1 L3 -> memb_and_rest F L3 L2 ->
  exists L5, split L5 L1 L2 /\ memb_and_rest F L4 L5.

induction on 1. intros.
  case H1. case H2.
    case H2.
      apply split_implies_list to H3.
        witness L5. search.
      apply IH to H3 H4. witness (X :: L6).
        search.
    apply IH to H3 H2.
      witness (X :: L7). search.

% Theorem split_lemma : forall X L L1 L2,
%   is_list L ->
%   split (X :: L) (X :: L1) L2
%   -> split L L1 L2.
% 
% induction on 1. intros.
% case H1 (keep).
%   case H2.
%     case H3.
%     search.
%   case H2 (keep).
% %    skip. % This case is invalid. We have to find a way to show abella that...
% %    search.

%          L
% |--------------------|
%     L1
% |----------|
% F :: [ L1' ] :: [ L2 ]
%      |---------------|
%             L'
%
% Theorem subsplit : forall F L L1 L2 L' L1',
%   split L L1 L2 -> memb_and_rest F L L' -> memb_and_rest F L1 L1' ->
%   split L' L1' L2.
% 

Theorem add_to_membrest1 : forall F1 L L' R,
  memb_and_rest F1 L L' -> is_list R ->
  exists S, memb_and_rest F1 S R.

intros. case H1.
  case H2. witness (F1 :: nil).
    search. witness (F1 :: X :: L1).
      search.
  case H2. witness (F1 :: nil). search.
  witness (F1 :: X :: L2). search.

%           D
% |------------------|
%  F1 :: [ D2 ] :: F2
% |-----------|
%      D1
%        |-----------|
%             D'  
Theorem membrest_implication1 : forall F1 F2 L L' L1,
  memb_and_rest F1 L L' -> memb_and_rest F2 L L1 ->
  exists L2, (F1 = F2 /\ L' = L1) \/ memb_and_rest F1 L1 L2.

induction on 1. intros. case H1.
  case H2. witness L1. left. search.
  witness R. right. apply membrest_implies_list to H4.
    search.
  case H2.
    witness R. right. search.
    apply IH to H3 H4.
    case H5.
      witness L2. left.
        search.
      witness (Y :: L3). right.
        search.

%       D
% |-----------|    
%  F1 :: [ D' ]  where F2 belongs to D'
%
%       D'
% |-----------|
%  F2 :: [ D1 ]
%
Theorem membrest_implication2 : forall F1 F2 D D' D1,
  memb_and_rest F1 D D' -> memb_and_rest F2 D' D1 ->
  exists D2, memb_and_rest F2 D D2 /\ memb_and_rest F1 D2 D1.

induction on 1. induction on 2. intros.
case H1 (keep).
  case H2 (keep).
    witness (F1 :: D1). search.
    case H4 (keep).
      witness (F1 :: Y :: R). search.
      witness (F1 :: Y :: Y1 :: R1). split.
        search.
        apply membrest_implies_list to H2. search.
  case H2 (keep).
    witness L. apply membrest_implies_list to H3. search.
    apply IH1 to H3 H4. witness (Y :: D2). search.
 
Theorem split_membrest_disjunction : forall F L L1 L2 L3,
  split L L1 L2 -> memb_and_rest F L L3 ->
  exists L4 L5, memb_and_rest F L1 L4 \/ memb_and_rest F L2 L5.

induction on 1. intros. case H1.
  case H2. case H2.
    witness L3. % Generic variable
      witness L6. right. unfold.
        apply split_implies_list to H3.
          search.
      apply IH to H3 H4.
        witness L5. witness (X :: L7). case H5.
          left. search. right. search.
  case H2. witness L5. witness L3. % Same
    left. unfold. apply split_implies_list to H3.
      search.
    apply IH to H3 H4.
      case H5. witness (X :: L6). witness R.
        left. search.
    apply IH to H3 H4.
      witness (X :: L8). witness L9. case H7.
        left. search.
        right. search.

Theorem split_property1 : forall L1 L2 L3 L4 L5,
  split L1 L2 L3 -> split L4 L3 L5 -> 
  exists L6, split L6 L1 L5 /\ split L6 L2 L4.

induction on 1. induction on 2. intros.
case H1 (keep).
  case H2.
    exists nil. search.
    apply IH1 to H1 H3. exists (X :: L7). search.
  case H2.
    apply IH1 to H1 H4. exists (X1 :: L9). search.
    apply IH to H3 H4. exists (X :: L9). search.
  case H2 (keep).
    apply IH to H3 H2. exists (X :: L8). search.
    apply IH to H3 H4. exists (X :: X1 :: L9). search.
    apply IH to H3 H2. exists (X :: L10). search.

Theorem split_property2 : forall L L1 L2 L3 L4,
  split L L1 L2 -> split L1 L3 L4 ->
  exists L5, split L5 L4 L2 /\ split L L3 L5.

induction on 1. intros. case H1.
  case H2.
    witness nil. search.
  apply IH to H3 H2. witness (X :: L6). search.
  case H2.
    apply IH to H3 H4. witness (X :: L7). search.
    apply IH to H3 H4. witness L7. search.

Theorem cut_admissibility : forall C G1 D1 D1' G2 G2' D2,
  formula C ->
  prove G1 D1 -> prove G2 D2 ->
  memb_and_rest C D1 D1' -> memb_and_rest C G2 G2' ->
  exists G3 D3,
  split G3 G2' G1 /\ split D3 D2 D1' /\ 
  prove G3 D3.

induction on 1. induction on 2. induction on 3. intros.

% Tensor case
case H1 (keep).
  % Unfolds the induction on the left premise (cut-formula in the succedent)
  case H2 (keep).

    % init case, trivial
    case H9. case H4. case H11.

    % oneR case, trivial
    case H8. case H4. case H10.

    % oneL case, permutes down
    apply IH1 to H1 H9 H3 H4 H5.
    apply add_to_split_right to H10 H8.
    witness L'. witness D3. split.
      search. search. search.

    % tensorL case, permutes down
    apply IH1 to H1 H11 H3 H4 H5.
    apply remove_from_split_right to H12 H9.
    apply remove_from_split_right to H15 H10.
    apply add_to_split_right to H17 H8.
    witness L'. witness D3.
      search.

    % tensorR case, permutes down
    apply membrest_implication1 to H4 H8.
    case H15. skip. % F = C, i.e., the tensor rule is applied to the cut-formula
      % case H3.
      % case H16. case H5. case H19. case H5.
      % apply membrest_implication1 to H5 H16.
      % case H18.
    apply split_membrest_disjunction to H9 H16.
    case H17.
      apply membrest_implication2 to H11 H18.
      apply IH1 to H1 H13 H3 H19 H5.
    % apply membrest_implication1 to H11 H19.
    % case H24. skip. % A1 = A tensor B
    apply remove_from_split_right to H22 H20.
    apply split_property1 to H21 H10.
    rename D1' to D1minusC.
    rename D' to D1minusA1*B1.
    rename D1'1 to D3minusA1.
    rename D2' to D4minusB1.
    rename L2 to D1minusA1*B1minusC.
    rename L4 to D3minusA1minusC.
    rename D5 to D3minusC.
    rename D6 to D2plusD3minusC.
    rename L1 to D2plusD3minusCminusA1.

    apply split_implies_list to H24.
    apply membrest_implies_list to H12.
    apply split_exists to H28 H32.
    apply split_property2 to H33 H24.
    apply add_to_split_left to H34 H18.
