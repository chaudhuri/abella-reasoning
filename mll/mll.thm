Kind atm type.

Type a, b, c, d, e, f atm.

%% We reuse the o type to define LL formulas
Type atom, natom   atm -> o.
Type tens, par     o -> o -> o.
Type one, bot      o.

Define is_fm : o -> prop by
; is_fm (atom A)
; is_fm (natom A)
; is_fm (tens A B) := is_fm A /\ is_fm B
; is_fm (par A B) := is_fm A /\ is_fm B
; is_fm one
; is_fm bot
.

Define dual : o -> o -> prop by
; dual (atom A) (natom A)
% ; dual (natom A) (atom A)
; dual (tens A B) (par AA BB) := dual A AA /\ dual B BB
% ; dual (par A B) (tens AA BB) := dual A AA /\ dual B BB
; dual one bot
% ; dual bot one
.

Theorem dual_is : forall A B, dual A B -> is_fm A /\ is_fm B.
induction on 1. intros. case H1.
  search.
%  search.
  apply IH to *H2. apply IH to *H3. search.
%  apply IH to *H2. apply IH to *H3. search.
  search.
%  search.

Import "../lib/merge" with is_o := is_fm.

Define mll : olist -> prop by
; mll L :=
    exists A, adj (natom A :: nil) (atom A) L

; mll L :=
    exists A B LL JJ KK J K,
      adj LL (tens A B) L /\
      merge JJ KK LL /\
      adj JJ A J /\ mll J /\
      adj KK B K /\ mll K

; mll (one :: nil)

; mll L :=
    exists A B LL J K,
      adj LL (par A B) L /\
      adj LL A J /\
      adj J B K /\
      mll K

; mll L :=
    exists LL,
      adj LL bot L /\
      mll LL
.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem generalized_id : forall A B, dual A B -> mll (A :: B :: nil).
induction on 1. intros. case H1.
  search.
  apply IH to H2. apply IH to H3.
   apply dual_is to H2. apply dual_is to H3.
   unfold 4. witness AA. witness BB. witness tens A1 B1 :: nil.
   witness tens A1 B1 :: AA :: nil.
   witness tens A1 B1 :: AA :: BB :: nil.
   split. search. search. search.
   unfold 2. witness A1. witness B1.
   witness AA :: BB :: nil.
   witness AA :: nil. witness BB :: nil.
   witness A1 :: AA :: nil. witness B1 :: BB :: nil.
   search.
  search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem adj_nil_1 : forall A L, adj nil A L -> L = A :: nil.
intros. case H1. search.

Theorem perm_nil_1 : forall L, perm nil L -> L = nil.
intros. case H1. search. case H2.

Theorem mll_perm : forall K L,
  mll K -> perm K L -> mll L.
induction on 1. intros. case H1.
  case H3.
    apply perm_cons_1 to *H2.
     apply perm_cons_1 to *H7. case H9. case H8. search. case H10.
    apply perm_cons_1 to *H2. apply adj_nil_1 to *H5.
     apply perm_cons_1 to *H7. apply adj_swap to *H8 *H6.
     apply perm_nil_1 to *H9. apply adj_nil_1 to *H10.
     unfold 1. search.

  apply adj_2_is_o to H5. apply adj_1_is_list to H5.
   apply adj_2_is_o to H7. apply adj_1_is_list to H7.
   assert perm J (A :: JJ).
     apply perm_refl to H10. search.
   assert perm K1 (B :: KK).
     apply perm_refl to H12. search.
   apply IH to *H6 *H13.
   apply IH to *H8 *H14.
   apply adj_perm_full to H2 H3. apply perm_merge_3 to *H4 *H18.
   unfold 2. search.

  case H2. case H3.
    apply perm_nil_1 to *H5. apply adj_nil_1 to *H4. search.
    case H7.

  apply adj_perm_full to *H2 *H3.
   assert perm J (A :: KK).
     apply adj_1_is_list to H7. apply adj_2_is_o to H4. search.
   assert perm K1 (B :: A :: KK).
     apply adj_1_is_list to H7. apply adj_2_is_o to H4. apply adj_2_is_o to H5.
      search.
   apply IH to *H6 *H10.
   apply adj_1_is_list to H7. apply adj_2_is_o to H4. apply adj_2_is_o to H5.
   unfold 4. search.

  apply adj_perm_full to *H2 *H3.
   apply IH to *H4 *H6.
   unfold 5. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Inversion theorems

Theorem bot_inv : forall J L,
  mll L -> adj J bot L -> mll J.
induction on 1. intros. case H1.
  apply adj_same_result_diff to H2 H3. case H4.
   case H5. case H7.

  apply adj_same_result_diff to H2 H3. case H9.
   apply merge_unadj_3 to H4 H10. case H11.
    apply adj_swap to H12 H5. apply IH to *H6 H15.
     apply merge_unadj_1 to H4 H12.
     apply adj_swap to H17 H3.
     assert mll U1. apply adj_same_result to H20 H2. backchain mll_perm with K = U1.

    apply merge_unadj_2 to *H4 H12. apply adj_same_result to H14 H10.
     apply perm_merge_3 to *H15 *H16.
     apply adj_swap to H12 H7. apply IH to *H8 H19.
     apply adj_swap to H10 H3. assert mll U1.
     apply adj_same_result to H22 H2. backchain mll_perm with K = U1.

  case H2. case H4.

  apply adj_same_result_diff to H2 H3. case H7.
   apply adj_swap to H8 H4.  apply adj_swap to H10 H5.
   apply IH to *H6 H12.
   apply adj_swap to H8 H3. assert mll U2.
   apply adj_same_result to H15 H2. backchain mll_perm with K = U2.

  apply adj_same_result to H3 H2. backchain mll_perm.

Theorem par_inv : forall L JJ A B,
  mll L -> adj JJ (par A B) L ->
  exists KK LL, adj JJ A KK /\ adj KK B LL /\ mll LL.
induction on 1. intros. case H1.
  apply adj_same_result_diff to H2 H3. case H4.
   case H5. case H7.

  apply adj_same_result_diff to H2 H3. case H9.
  apply merge_unadj_3 to *H4 H10. case H11.
    apply adj_swap to H12 *H5. apply IH to *H6 *H15.
     apply adj_swap to *H14 *H16. apply adj_swap to *H20 *H17.
     apply adj_1_is_list to H10. apply adj_2_is_o to H19. apply adj_2_is_o to H21.
     assert merge U2 KK (A :: B :: KK1).
     apply adj_2_is_o to H3.
     assert mll (tens A1 B1 :: A :: B :: KK1).
     apply adj_swap to *H10 *H3.
     apply adj_same_result to H30 H2. apply adj_perm_full to H31 H29.
     apply adj_1_is_list to *H2.
     assert perm (tens A1 B1 :: A :: B :: KK1) (A :: B :: JJ).
     apply mll_perm to *H28 *H35.
     witness A :: JJ. witness A :: B :: JJ. search.

    %% symmetric case

  % other cases
abort.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Theorem cut : forall A B JJ J KK K LL,
  dual A B ->
  adj JJ A J -> mll J ->
  adj KK B K -> mll K ->
  merge JJ KK LL ->
  mll LL.
induction on 1. induction on 3. intros. case H3.
  %% identity
  apply adj_same_result_diff to H2 H7. case H8.
    %% Cut formula principal
    case H1. case H9. case H11.
      apply adj_same_result to H2 H7. case H15. case H12.
       case H10.
       apply merge_move_12 to _ H4 H6.
       apply merge_nil_perm to H21. backchain mll_perm.
        case H20.
      case H14.
    %% Cut formula is not principal -- impossible
    case H9. case H1. case H11.

  %% tensor
  apply adj_same_result_diff to H2 H7. case H13.
    %% cut formula is the tensor
    case H1.
abort.
