Specification "llf".

Type $pf pf -> o.
Type $natom atm -> o.
Define is_fm : o -> prop by
; is_fm ($pf P) := exists N, {dual P N}
; is_fm ($natom A).

Import "../lib/merge" with is_o := is_fm.

Theorem $dual_det :
  (forall P1 P2 N, {dual P1 N} -> {dual P2 N} -> P1 = P2)
/\
  (forall P N1 N2, {dual P N1} -> {dual P N2} -> N1 = N2).
IH1 : induction on 1 1. split.
intros. case H1.
  case H2. search.
  case H2. apply IH1 to *H3 *H5. apply *IH1 to *H4 *H6. search.
  case H2. search.
  case H2. apply IH1 to *H3 *H5. apply *IH1 to *H4 *H6. search.
  case H2. search.
  case H2. apply IH1 to *H3 *H4. search.
  case H2. apply IH2 to *H3 *H4. search.
  case H2. apply IH2 to *H3 *H4. search.
intros. case H1.
  case H2. search.
  case H2. apply IH2 to *H3 H5. apply *IH2 to *H4 *H6. search.
  case H2. search.
  case H2. apply IH2 to *H3 H5. apply *IH2 to *H4 *H6. search.
  case H2. search.
  case H2. apply IH2 to *H3 *H4. search.
  case H2. apply IH1 to *H3 *H4. search.
  case H2. apply IH1 to *H3 *H4. search.

Split $dual_det as dual_det_1, dual_det_2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Context extensions based on focusing patterns

Kind cx type.
Type $cx olist -> olist -> cx.
Define no_atoms : olist -> prop by
; no_atoms nil
; no_atoms ($pf P :: L) := no_atoms L.
Theorem no_atoms_adj : forall LL P L,
  no_atoms LL -> adj LL ($pf P) L -> no_atoms L.
induction on 1. intros. case H1.
  case H2. search.
  case H2. search. apply IH to H3 H5. search.
Theorem no_atoms_unadj : forall LL P L,
  no_atoms L -> adj LL P L -> no_atoms LL /\ exists A, P = $pf A.
induction on 1. intros. case H1.
  case H2.
  case H2. search. apply IH to H3 H5. search.
Theorem no_atoms_merge : forall J K L,
  no_atoms J -> no_atoms K -> merge J K L -> no_atoms L.
induction on 3. intros. case H3.
  search.
  apply no_atoms_unadj to *H1 *H4. apply IH to *H7 *H2 *H6. backchain no_atoms_adj.
  apply no_atoms_unadj to *H2 *H4. apply IH to *H1 *H7 *H6. backchain no_atoms_adj.
Theorem no_atoms_unmerge : forall J K L,
  no_atoms L -> merge J K L -> no_atoms J /\ no_atoms K.
induction on 2. intros. case H2.
  search.
  apply no_atoms_unadj to *H1 *H4. apply IH to *H6 *H5. apply no_atoms_adj to *H7 *H3. search.
  apply no_atoms_unadj to *H1 *H4. apply IH to *H6 *H5. apply no_atoms_adj to *H8 *H3. search.
Define is_cx : cx -> prop by
  is_cx ($cx U L) := is_list U /\ no_atoms U /\ is_list L.

Define extension : foc -> olist -> olist -> prop by
; extension (fatom A) nil ($natom A :: nil) := is_fm ($pf (atom A))
; extension (fshift N) nil ($pf P :: nil) := {dual P N} /\ is_fm ($pf P)
; extension (fbang N) ($pf P :: nil) nil := {dual P N} /\ is_fm ($pf P)
; extension (fjoin F1 F2) U L :=
    exists U1 U2 L1 L2,
      extension F1 U1 L1 /\
      extension F2 U2 L2 /\
      merge U1 U2 U /\ merge L1 L2 L
; extension femp nil nil.

Theorem extension_is : forall F U L,
  extension F U L -> is_list U /\ no_atoms U /\ is_list L.
induction on 1. intros. case H1.
  search.
  search.
  search.
  apply IH to H2. apply IH to H3. apply no_atoms_merge to *H7 *H10 H4.
    apply merge_3_is_list to *H4. apply merge_3_is_list to *H5. search.
  search.

Theorem extension_exists : forall F P,
  {subf F P} -> exists U L, extension F U L.
induction on 1. intros. case H1.
  search. search. search.
  apply IH to *H2. apply IH to *H3.
   apply extension_is to H4. apply extension_is to H5.
   apply merge_exists to *H6 *H9. apply merge_exists to *H8 *H11.
   search.
  apply IH to *H2. search.
  apply IH to *H2. search.
  apply IH to *H2. search.
  search.

Theorem extend_det : forall F U1 U2 L1 L2,
  extension F U1 L1 -> extension F U2 L2 -> perm U1 U2 /\ perm L1 L2.
induction on 1. intros. case H1.
  case H2. search.
  case H2. apply dual_det_1 to *H3 H5. search.
  case H2. apply dual_det_1 to *H3 H5. search.
  case H2. apply IH to *H3 *H7. apply IH to *H4 *H8.
    apply perm_merge_1 to *H5 *H11. apply perm_merge_2 to *H15 *H13.
    apply merge_perm_det to *H16 *H9.
    apply perm_merge_1 to *H6 *H12. apply perm_merge_2 to *H18 *H14.
    apply merge_perm_det to *H19 *H10.
    search.
  case H2. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Synthetic first-order LL

Define
  ll : olist -> olist -> prop,
  llfoc : olist -> olist -> foc -> prop
by
% linear decide
; ll U L :=
    exists P LL, adj LL ($pf P) L /\
    exists F, {subf F P} /\
    llfoc U LL F
% unrestricted decide
; ll U L :=
    exists P UU, adj UU ($pf P) U /\
    exists F, {subf F P} /\
    llfoc U L F

% init
; llfoc U ($natom A :: nil) (fatom A) :=
    is_list U /\ no_atoms U
% linear release + async + store
; llfoc U L (fshift N) :=
    is_list U /\ no_atoms U /\ is_list L /\
    exists P, {dual P N} /\
    forall F, {subf F P} ->
    exists UE LE, extension F UE LE /\
    exists UU, merge U UE UU /\
    exists LL, merge L LE LL /\
    ll UU LL
% unrestricted release + async + store
; llfoc U nil (fbang N) :=
    is_list U /\ no_atoms U /\
    exists P, {dual P N} /\
    forall F, {subf F P} ->
    exists UE LL, extension F UE LL /\
    exists UU, merge U UE UU /\ ll UU LL
% multiplicative split
; llfoc U L (fjoin F1 F2) :=
    exists L1 L2, merge L1 L2 L /\
    llfoc U L1 F1 /\ llfoc U L2 F2
% linear emptiness test
; llfoc U nil femp :=
    is_list U /\ no_atoms U.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Well-formedness of context

Theorem $ll_is :
  (forall U L, ll U L -> is_list U /\ no_atoms U /\ is_list L)
/\
  (forall F U L, llfoc U L F -> is_list U /\ no_atoms U /\ is_list L).
IH1 : induction on 1 1. split.
intros. case H1.
  apply IH2 to H4. apply adj_3_is_list to H2. search.
  apply IH2 to H4. apply adj_3_is_list to H2. search.
intros. case H1.
  search. search. search.
  apply IH2 to *H3. apply IH2 to *H4. apply merge_3_is_list to H2. search.
  search.

Split $ll_is as ll_is, llfoc_is.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Monotonicity of unrestricted contexts

Theorem $monotone :
  (forall U1 U2 L,
     ll U1 L ->
     is_list U2 -> no_atoms U2 ->
     subset U1 U2 ->
     ll U2 L)
/\
  (forall U1 U2 L F,
     llfoc U1 L F ->
     is_list U2 -> no_atoms U2 ->
     subset U1 U2 ->
     llfoc U2 L F).
IH1 : induction on 1 1. split.
intros. case H1.
  apply IH2 to *H7 _ _ _. search.
  apply IH2 to *H7 _ _ _. H4 : case H4. apply *H4 to H5. search.
intros. case H1.
  % fatom
  search.
  % fshift
  unfold 4. search. search. search. witness P. split. search.
   intros. apply *H9 to *H10.
   witness UE, LE. split. search.
   Hn : assert exists VV, merge U2 UE VV.
      backchain merge_exists. backchain merge_2_is_list. case Hn.
   witness VV. split. search.
   witness LL. split. search.
   apply merge_3_is_list to H15.
   apply extension_is to H11. apply no_atoms_merge to H3 H18 H15.
   backchain IH1.
   unfold. intros. apply merge_unadj_3 to *H12 *H21. case H22.
     H4 : case H4. apply *H4 to *H23.
      apply merge_unadj_1 to *H15 *H25. search.
     apply merge_unadj_2 to *H15 *H23. search.
  % fbang
  unfold 5. search. search. witness P. split. search. intros.
   apply *H8 to *H9. witness UE, LL. split. search.
   Hn : assert exists VV, merge U2 UE VV.
      backchain merge_exists. backchain merge_2_is_list. case Hn.
   witness VV. split. search.
   apply merge_3_is_list to H13.
   apply extension_is to H10. apply no_atoms_merge to *H3 *H16 H13.
   backchain IH1.
   unfold. intros. apply merge_unadj_3 to *H11 *H19. case H20.
     H4 : case H4. apply *H4 to *H21.
      apply merge_unadj_1 to *H13 *H23. search.
     apply merge_unadj_2 to *H13 *H21. search.
  % fjoin
  apply IH2 to *H6 _ _ _. apply IH2 to *H7 _ _ _. search.
  % femp
  search.

Split $monotone as ll_monotone, llfoc_monotone.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generalized identity

Theorem id : forall P N F U L,
  {dual P N} ->
  {subf F P} ->
  extension F U L ->
  llfoc U L F.
induction on 1. intros. case H1.
  % atoms
  case H2. case H3. search.
  % tensor
  case H2. case H3. unfold.
   apply IH to *H4 *H6 *H8.
   apply IH to *H5 *H7 *H9.
   apply merge_subset to H10.
   apply merge_subset to _ with J = U3, K = U2, L = U. backchain merge_sym.
   apply llfoc_is to H12. apply llfoc_is to H13.
   apply no_atoms_merge to *H17 *H20 H10. apply merge_3_is_list to H10.
   apply llfoc_monotone to H12 _ _ H14.
   apply llfoc_monotone to H13 _ _ H15.
   search.
  % one
  case H2. case H3. search.
  % plus
  case H2.
    apply IH to *H4 *H6 *H3. search.
    apply IH to *H5 *H6 *H3. search.
  % zero
  case H2.
  % exists
  case H2. H4 : inst *H4 with n1 = T.
   apply IH to *H4 *H5 *H3. search.
  % bang
  case H2. case H3.
   apply dual_det_1 to H4 *H5. apply dual_det_1 to H4 *H6.
   unfold. search. search. witness P3. split. search. intros.
   apply extension_exists to H8. witness U1, L1. split. search.
   apply IH to H4 H8 *H9.
   witness ($pf P3 :: U1). split. apply llfoc_is to H10.
     unfold 2. witness $pf P3, nil, U1. split. search. search.
     backchain merge_nil_equal.
    unfold 2. witness P3, U1. split. apply llfoc_is to H10. search.
    witness F1. split.  search.
    backchain llfoc_monotone. apply llfoc_is to H10. search.
    apply llfoc_is to H10. search.
  % shift
  case H2. case H3.
  apply dual_det_1 to H4 *H5. apply dual_det_1 to H4 *H6.
  unfold. search. search. search. witness P3. split. search. intros.
  apply extension_exists to H8. witness U1, L1. split. search.
  apply merge_nil_equal to _ with L = U1. apply extension_is to H9. search.
  witness U1. split. search.
  apply IH to H4 H8 *H9.
  witness $pf P3 :: L1. split. apply llfoc_is to H11.
    unfold 2. witness $pf P3, nil, L1. split. search. search.
    backchain merge_nil_equal.
  unfold 1. witness P3, L1. apply llfoc_is to H11. search.
