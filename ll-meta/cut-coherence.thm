Kind atm type.

Import "../one-sided/mall".

%% Elements used in the specification of systems.

%% Object logic formulas and atoms
Kind olfm type.
Kind olatm type.

% The object logic contains atoms and binary connectives. These can possibly be
% augmented with higher arities connectives or quantifiers.
Type olatom olatm -> olfm.
Type olcon2 olfm -> olfm -> olfm.

%% The induction measure
%
% Either we instantiate is_olfm with a is_fm from a specification of a real
% logic or we use this more generic one. I see two reasons to use a generic
% one: (1) the theorem should not depend on the object logic; and (2) there
% will be less cases if we just have unnamed binary, terciary, etc.
% connectives.
%
Define is_olfm : olfm -> prop by
; is_olfm (olatom A)
; is_olfm (olcon2 A B) := is_olfm A /\ is_olfm B.

%% Mapping OL formulas to LL atoms
Type lft olfm -> atm.
Type rgt olfm -> atm.

%% Quantifiers for formulas of the object logic
%Type all (olfm -> o) -> o.
%Type ex (olfm -> o) -> o.

%% The specification of a formula maps the lft or rgt atoms to the body
Kind spec type.

Type spnil spec.
% Type spcons spec -> (olfm -> olfm -> atm) -> (olfm -> olfm -> o) -> spec.
Type spcons spec -> atm -> o -> spec.

%% There is a restriction regarding variables that can occur in the head and
%% body of a bipole that is not taken into account here.
Define is_spec : spec -> prop by
; is_spec spnil
; is_spec (spcons S (lft A) B) := is_spec S /\ is_olfm A /\ is_fm B
; is_spec (spcons S (rgt A) B) := is_spec S /\ is_olfm A /\ is_fm B.

%% build \mathcal{X}
Define translate : spec -> olist -> prop by
; translate spnil nil
; translate (spcons S H B) (F :: R) :=
    translate S R /\ 
%%    F = all OA\ all OB\ tens (natom (H OA OB)) (B OA OB).
    F = tens (natom H) B.

%% Define cut_coherent : spec -> prop by
%% TODO: define cut-coherence or prove it?

Theorem apply_def : forall J H B K L LL,
  adj J (tens (natom H) B) K ->
  adj K (atom H) L ->
  mall L ->
  adj J B LL -> mall LL.
induction on 3. intros. case H3.
  % Init (base case)
  case H5.
    case H2.
      case H1. case H11.
      case H9. case H11.
    apply adj_nil_1 to H7. case H2. case H9.
      case H1. case H13.
      case H11.
  % tensor
  apply adj_swap to H1 H2.
  apply adj_same_result_diff to H5 H12.
  case H13.
  abort.
% This is painfully hard.

    
Theorem to_atomic_cuts : forall S X G Th B Cut ACut,
  is_spec S -> translate S X ->
  append X G Th ->
%  cut_coherent S -> We will need this at some point.
  is_olfm B ->
  Cut = tens (atom (lft B)) (atom (rgt B)) ->
  mall (Cut :: Th) ->
  exists A,
  ACut = tens (atom (lft (olatom A))) (atom (rgt (olatom A))) ->
  mall (ACut :: Th).

induction on 4. intros.
% Induction on B
case H4.
  % Case 1: the formula is atomic
  exists A. intros. case H7. case H5. search.
  % Case 2: the formula contains a connective
  case H5. case H6.
    % Casing on the linear logic proof with the non-atomic cut
    % How to deal with the cases where the tensor is not the first formula
    % to be decomposed?
    % Case 2.1: initial
    skip.
    % Case 2.2: tensor
    case H9.
      % Case 2.2.1: tensor is applied to the cut encoding
      
      % Case 2.2.2: tensor is not applied to the cut encoding
      skip.
    % Case 2.3: par
    skip.
    % Case 2.4: bot
    skip.
    % Case 2.5: with
    skip.
    % Case 2.6: top
    skip.
    % Case 2.7: plus 1
    skip.
    % Case 2.8: plus 2
    skip.

