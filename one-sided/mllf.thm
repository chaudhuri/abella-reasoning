Kind atm type.

Type a, b, c, d, e, f atm.

Kind pf, nf  type.

Type atom  atm -> pf.
Type tens  pf -> pf -> pf.
Type one   pf.
Type shp   nf -> pf.

Type natom atm -> nf.
Type par   nf -> nf -> nf.
Type bot   nf.
Type shn   pf -> nf.

Define dual : pf -> nf -> prop by
; dual (atom A) (natom A)
; dual (tens P Q) (par M N) := dual P M /\ dual Q N
; dual one bot
; dual (shp N) (shn P) := dual P N
.

Theorem $dual_det :
  (forall P1 P2 N, dual P1 N -> dual P2 N -> P1 = P2)
/\
  (forall P N1 N2, dual P N1 -> dual P N2 -> N1 = N2).
IH1 : induction on 1 1. split.
intros. case H1.
  case H2. search.
  case H2. apply IH1 to *H3 *H5. apply *IH1 to *H4 H6. search.
  case H2. search.
  case H2. apply IH2 to *H3 *H4. search.
intros. case H1.
  case H2. search.
  case H2. apply IH2 to *H3 H5. apply *IH2 to *H4 *H6. search.
  case H2. search.
  case H2. apply IH1 to *H3 *H4. search.

Split $dual_det as dual_det_1, dual_det_2.

Kind foc type.
Type fatom  atm -> foc.
Type fshift nf -> foc.
Type fjoin  foc -> foc -> foc.
Type femp   foc.

Define subf : foc -> pf -> prop by
; subf (fatom A) (atom A)
; subf (fshift N) (shp N) := exists P, dual P N
; subf (fjoin F1 F2) (tens P Q) := subf F1 P /\ subf F2 Q
; subf femp one
.

Type $pf pf -> o.
Type $natom atm -> o.
Define is_fm : o -> prop by
; is_fm ($pf P) := exists N, dual P N
; is_fm ($natom A)
.
Import "../lib/merge" with is_o := is_fm.

Define extend : olist -> foc -> olist -> prop by
; extend LL (fatom A) L :=
    adj LL ($natom A) L
; extend LL (fshift N) L :=
    exists P, dual P N /\ adj LL ($pf P) L
; extend LL (fjoin F1 F2) L :=
    exists K, extend LL F1 K /\ extend K F2 L
; extend L femp L := is_list L
.

Theorem extend_is : forall K F L,
  extend K F L -> is_list K /\ is_list L.
induction on 1. intros. case H1.
  apply adj_1_is_list to H2. apply adj_3_is_list to H2. search.
  apply adj_1_is_list to H3. apply adj_3_is_list to H3. search.
  apply IH to H2. apply IH to H3. search.
  search.

Define
  mll : olist -> prop,
  mllfoc : olist -> foc -> prop
by
; mll L :=
    exists P LL, adj LL ($pf P) L /\
    exists F, subf F P /\
    mllfoc LL F

; mllfoc ($natom A :: nil) (fatom A)

; mllfoc L (fshift N) :=
    exists P, dual P N /\
    forall F, subf F P ->
    exists LL, extend L F LL /\ mll LL

; mllfoc L (fjoin F1 F2) :=
    exists J K, merge J K L /\
    mllfoc J F1 /\ mllfoc K F2

; mllfoc nil femp
.


Theorem adj_merge : forall K A L,
  adj K A L ->
  merge K (A :: nil) L.
intros. apply adj_2_is_o to H1.
unfold 3. witness A, nil, K. split.
  search. search.
  backchain merge_sym. backchain merge_nil_equal.
   backchain adj_1_is_list.

Theorem extend_merge : forall J F L K JK,
  extend J F L ->
  merge J K JK ->
  exists LK, merge L K LK /\ extend JK F LK.
induction on 1. intros. case H1.
  apply merge_3_is_list to H2.
   witness $natom A :: JK. search.
  apply merge_3_is_list to H2.
   witness $pf P :: JK. search.
  apply IH to *H3 *H2. apply IH to *H4 *H5.
   search.
  apply merge_3_is_list to H2. search.

Theorem extend_cons : forall J F L A,
  extend J F L ->
  is_fm A ->
  extend (A :: J) F (A :: L).
induction on 1. intros. case H1.
  search.
  search.
  apply IH to *H3 H2. apply IH to *H4 H2. search.
  search.

Theorem unextend : forall J K L F LF,
  merge J K L ->
  extend L F LF ->
  exists KF, extend K F KF /\ merge J KF LF.
induction on 2. intros. case H2.
  %% atom
  Ht : assert 0 exists KF, adj K ($natom A) KF.
    apply merge_2_is_list to H1. apply adj_2_is_o to H3.
    apply adj_exists to H5 H4. search. case Ht.
   witness KF. split. search.
   apply adj_merge to *H3. apply adj_merge to *H4.
   Ht : assert 0 exists JKF, merge J KF JKF.
     apply merge_1_is_list to H1. apply merge_3_is_list to H6.
     apply merge_exists to H7 H8. search. case Ht.
   apply merge_assoc to *H1 *H6 H7 *H5.
   backchain perm_merge_3.
  %% shift
  Ht : assert 0 exists KF, adj K ($pf P) KF.
    apply merge_2_is_list to H1. apply adj_2_is_o to H4.
    apply adj_exists to H6 H5. search. case Ht.
   witness KF. split. search.
   apply adj_merge to *H4. apply adj_merge to *H5.
   Ht : assert 0 exists JKF, merge J KF JKF.
     apply merge_1_is_list to H1. apply merge_3_is_list to H7.
     apply merge_exists to H8 H9. search. case Ht.
   apply merge_assoc to *H1 *H7 H8 *H6.
   backchain perm_merge_3.
  %% join
  apply IH to H1 *H3. apply IH to H6 *H4.
  search.
  %% empty
  apply merge_2_is_list to H1. search.

Theorem extend_exists : forall L F P,
  is_list L -> subf F P ->
  exists K, extend L F K.
induction on 2. intros. case H2.
  search.
  search.
  apply IH to *H1 H3. apply extend_is to H5.
   apply IH to *H7 *H4. search.
  search.

Theorem id : forall P N F L,
  dual P N ->
  subf F P ->
  extend nil F L ->
  mllfoc L F.
induction on 1. intros. case H1.
  case H2. case H3. case H4. search.

  case H2. case H3. unfold.
  apply IH to *H4 *H6 *H8. witness K.
  assert merge K nil K. apply extend_is to H9. backchain merge_sym. backchain merge_nil_equal.
  apply unextend to *H11 *H9.
  apply IH to *H5 *H7 *H12. search.

  case H2. case H3. search.

  case H2. apply dual_det_1 to H4 *H5.
  case H3. apply dual_det_1 to H4 *H6.
  case H7. case H8. apply dual_det_2 to H4 *H10. clear H9.
  unfold. witness P2. split. search. intros.
  Ht : assert 0 exists L, extend nil F1 L.
    apply extend_exists to _ H11 with L = nil. search.
    case Ht.
  apply IH to H4 H11 H12.
  witness $pf P2 :: L1. split.
    backchain extend_cons.
  unfold. witness P2, L1. split.
    apply extend_is to H12. search.
  witness F1. split. search.
  backchain IH.