%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                    %%
%%       MALL specification in        %%
%%       Abella (.thm)                %%
%%                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% More verbose output
Set instantiations on.
Set witnesses on.
Set subgoals off.

Type a, b, c, d                o.
Type tensor, par, plus, with   o -> o -> o.
Type one, bot, zero, top       o.
Type not, atom                 o -> o.

Define formula : o -> prop by
  formula (tensor A B) := formula A /\ formula B ;
  formula (plus A B) := formula A /\ formula B ;
  formula (with A B) := formula A /\ formula B ;
  formula (par A B) := formula A /\ formula B ;
  formula (zero) ; 
  formula (one) ; 
  formula (bot) ;
  formula (top) ; 
  formula (atom A).

Import "../lib/merge" with is_o := formula.

Define prove : olist -> olist -> prop by
  % Identity rules
  prove G D := exists A, adj nil (atom A) G /\ adj nil (atom A) D ;

  % Multiplicative rules
  % oneR
  prove G D := G = nil /\ adj nil one D ;
  % oneL
  prove G D := exists G', adj G' one G /\ prove G' D ;
  % tensorL
  prove G D := exists A B G' G1 G2, 
    adj G' (tensor A B) G /\ adj G2 A G1 /\ adj G' B G2 /\ prove G1 D ;
  % tensorR
  prove G D := exists A B D' D1 D2 D1' D2' G1 G2, 
    adj D' (tensor A B) D /\ merge D1' D2' D' /\ merge G1 G2 G /\ 
    adj D1' A D1 /\ adj D2' B D2 /\ prove G1 D1 /\ prove G2 D2 ;
  % botL
  prove G D := D = nil /\ adj nil bot G ;
  % botR
  prove G D := exists D', adj D' bot D /\ prove G D' ;
  % parR
  prove G D := exists A B D' D1 D2, 
    adj D' (par A B) D /\ adj D1 A D' /\ adj D2 B D1 /\ prove G D' ;
  % parL
  prove G D := exists A B G' G1 G2 G1' G2' D1 D2, 
    adj G' (par A B) G /\ merge G1 G2 G' /\ merge D1 D2 D /\ adj G1' A G1 /\ 
    adj G2' B G2 /\ prove G1 D1 /\ prove G2 D2 ;

  % Additive rules
  % zeroL
  prove G D := exists G', adj G' zero G ;
  % topR
  prove G D := exists D', adj D' top D ;
  % withL1
  prove G D := exists A B G' G1, 
    adj G' (with A B) G /\ adj G1 A G' /\ prove G' D ;
  % withL2
  prove G D := exists A B G' G1, 
    adj G' (with A B) G /\ adj G1 B G' /\ prove G' D ;
  % withR
  prove G D := exists A B D' D1 D2, 
    adj D' (with A B) D /\ adj D' A D1 /\ adj D' B D2 /\ prove G D1 /\ prove G D2 ;
  % plusR1
  prove G D := exists A B D' D1, 
    adj D' (plus A B) D /\ adj D1 A D' /\ prove G D' ;
  % plusR2
  prove G D := exists A B D' D1, 
    adj D' (plus A B) D /\ adj D1 B D' /\ prove G D' ;
  % plusL
  prove G D := exists A B G' G1 G2, 
    adj G' (plus A B) G /\ adj G' A G1 /\ adj G' B G2 /\ prove G1 D /\ prove G2 D.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Reasoning

Theorem cut_admissibility : forall C G1 D1 D1' G2 G2' D2,
  formula C ->
  prove G1 D1 -> prove G2 D2 ->
  adj D1' C D1 -> adj G2' C G2 ->
  exists G3 D3,
  merge G2' G1 G3 /\ merge D2 D1' D3 /\ 
  prove G3 D3.

induction on 1. induction on 2. induction on 3. intros.

% Tensor case
case H1 (keep).
  % Unfolds the induction on the left premise (cut-formula in the succedent)
  % Each case is a possible rule applied to the left premise.
  case H2 (keep).

    % init case -- invalid (contexts need to be empty)
    case H9. case H4. case H13.

    % oneR case -- invalid (contexts need to be empty)
    case H8. case H4. case H12.

    % oneL case -- permutes down
    apply IH1 to H1 H9 H3 H4 H5.
    apply add_to_merge_right to H8 H10.
    search.

    % tensorL case -- permutes down
    apply IH1 to H1 H11 H3 H4 H5.
    apply merge_unadj_2 to H12 H9.
    apply merge_unadj_2 to H16 H10.
    apply add_to_merge_right to H8 H18.
    search.

    % tensorR case -- principal or permutes down
    apply adj_same_result_diff to H4 H8.
    case H15.
      % 1. the cut-formula is principal. TODO
      skip.
      % 2. the tensorR is applied to another formula -- permutes down
      apply merge_unadj_3 to H9 H16.
      case H17.
        % 1. Cut-formula goes to the left premise of tensorR.
        apply adj_swap to H18 H11.
        apply IH1 to H1 H13 H3 H21 H5. 
        apply merge_unadj_2 to H23 H20.
        apply merge_3_is_list to H26. apply merge_2_is_list to H9.
        apply merge_exists to H27 H28.
        apply merge_3_is_list to H29. apply adj_2_is_o to H8.
        apply adj_exists to H31 H30.
        apply merge_2_is_list to H10. apply merge_3_is_list to H22.
        apply merge_exists to H33 H34.
        exists L1. exists M.
        split.
          % merge of antecedents
          apply merge_sym to H35.
          apply merge_1_is_list to H22. apply merge_3_is_list to H10.
          apply merge_exists to H37 H38.
          apply merge_assoc to H22 H10 H39 H36.
          apply perm_merge_3 to H39 H40. search. 

          % merge of succeedents
          apply merge_1_is_list to H23. apply merge_3_is_list to H19.
          apply merge_exists to H36 H37.
          apply merge_assoc to H26 H19 H38 H29. 
          apply merge_3_is_list to H38.
          apply adj_exists to H31 H40.
          apply adj_preserves_perm to H41 H32 H39.
          apply adj_implies_merge to H41.
          apply adj_implies_merge to H16. 
          apply adj_implies_merge to H8. 
          apply adj_implies_merge to H4.
          apply merge_sub to H44 H45 H46.
          apply merge_1_is_list to H38.
          apply adj_1_is_list to H4.
          apply merge_exists to H48 H49.
          apply merge_assoc to H38 H47 H50 H43. 
          apply perm_merge_3 to H50 H51.
          apply perm_merge_3 to H52 H42.
          search.

          % provability of conclusion
          unfold 5. exists A1. exists B1. exists L. exists D5. exists D4.
          exists LL. exists D2'. exists G5. exists G4.
          apply merge_sym to H35. search.

        % 2. Cut-formula goes to the right premise of tensorR. TODO (fetch from
        % the other computer)
        skip.

    % botL case -- invalid (contexts need to be empty)
    case H4.

    % botR case -- permutes down
    apply adj_same_result_diff to H4 H8.
    case H10.
    apply IH1 to H1 H9 H3 H11 H5.
    apply adj_swap to H11 H8.
    apply adj_same_result to H4 H16.
    apply add_to_merge_right to H15 H13.
    exists G3. exists M. split.
      search.
      apply perm_sym to H17. apply perm_merge_2 to H18 H20. search. 
      search.
    
    % parR case
    skip.

    % parL case
    skip.

    % zeroL case
    skip.

    % topR case
    skip.

    % withL1 case
    skip.

    % withL2 case
    skip.

    % withR case
    skip.

    % plusR1 case
    skip.

    % plusR2 case
    skip.

    % plusL case
    skip.

