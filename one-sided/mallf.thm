Specification "mallf".

Type $pf pf -> o.
Type $natom atm -> o.
Define is_fm : o -> prop by
; is_fm ($pf P) := exists N, {dual P N}
; is_fm ($natom A).

Import "../lib/merge" with is_o := is_fm.

Theorem $dual_det :
  (forall P1 P2 N, {dual P1 N} -> {dual P2 N} -> P1 = P2)
/\
  (forall P N1 N2, {dual P N1} -> {dual P N2} -> N1 = N2).
IH1 : induction on 1 1. split.
intros. case H1.
  case H2. search.
  case H2. apply IH1 to *H3 *H5. apply *IH1 to *H4 *H6. search.
  case H2. search.
  case H2. apply IH1 to *H3 *H5. apply *IH1 to *H4 *H6. search.
  case H2. search.
  case H2. apply IH1 to *H3 *H4. search.
  case H2. apply IH2 to *H3 *H4. search.
intros. case H1.
  case H2. search.
  case H2. apply IH2 to *H3 H5. apply *IH2 to *H4 *H6. search.
  case H2. search.
  case H2. apply IH2 to *H3 H5. apply *IH2 to *H4 *H6. search.
  case H2. search.
  case H2. apply IH2 to *H3 *H4. search.
  case H2. apply IH1 to *H3 *H4. search.

Split $dual_det as dual_det_1, dual_det_2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Context extensions based on focusing patterns

Define extension : foc -> olist -> prop by
; extension (fatom A) ($natom A :: nil) := is_fm ($pf (atom A))
; extension (fshift N)($pf P :: nil) := {dual P N} /\ is_fm ($pf P)
; extension (fjoin F1 F2) L :=
    exists L1 L2,
      extension F1 L1 /\
      extension F2 L2 /\
      merge L1 L2 L
; extension femp nil.

Theorem extension_is : forall F L, extension F L -> is_list L.
intros. case H1.
  search.
  search.
  backchain merge_3_is_list.
  search.

Theorem extension_exists : forall F P,
  {subf F P} -> exists L, extension F L.
induction on 1. intros. case H1.
  search.
  search.
  apply IH to *H2. apply IH to *H3.
   apply extension_is to H4. apply extension_is to H5.
   apply merge_exists to *H6 *H7. search.
  apply IH to *H2. search.
  apply IH to *H2. search.
  apply IH to *H2. search.
  search.

Theorem extension_det : forall F L1 L2,
  extension F L1 -> extension F L2 -> perm L1 L2.
induction on 1. intros. case H1.
  case H2. search.
  case H2. apply dual_det_1 to *H5 H3. search.
  case H2. apply IH to *H3 *H6. apply IH to *H4 *H7.
   apply perm_merge_1 to *H5 *H9. apply perm_merge_2 to *H11 *H10.
   backchain merge_perm_det.
  case H2. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Synthetic first-order MALL

Define
  mall : olist -> prop,
  mallfoc : olist -> foc -> prop
by
; mall L :=
    exists P LL, adj LL ($pf P) L /\
    exists F, {subf F P} /\
    mallfoc LL F

; mallfoc ($natom A :: nil) (fatom A)

; mallfoc L (fshift N) :=
    exists P, {dual P N} /\
    forall F, {subf F P} ->
    exists LE, extension F LE /\
    exists LL, merge L LE LL /\
    mall LL

; mallfoc L (fjoin F1 F2) :=
    exists J K, merge J K L /\
    mallfoc J F1 /\ mallfoc K F2

; mallfoc nil femp.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generalized identity

Theorem gid_lemma : forall P N F L,
  {dual P N} ->
  {subf F P} ->
  extension F L ->
  mallfoc L F.
induction on 1. intros. case H1.
  % atoms
  case H2. case H3. case H4. search.
  % tensor
  case H2. case H3. unfold.
  apply IH to *H4 *H6 *H8. apply IH to *H5 *H7 *H9.
  search.
  % par
  case H2. case H3. search.
  % plus
  case H2.
    apply IH to *H4 *H6 *H3. search.
    apply IH to *H5 *H6 *H3. search.
  % zero
  case H2.
  % exists
  case H2. inst *H4 with n1 = T. apply IH to *H6 *H5 *H3. search.
  % shift
  case H2. apply dual_det_1 to *H5 H4.
  case H3. apply dual_det_1 to *H6 H4.
  unfold. witness P1. split. search. intros.
  apply extension_exists to H8. witness L1. split. search.
  apply IH to H4 H8 H9.
  witness $pf P1 :: L1. split.
  apply extension_is to H9. apply merge_nil_equal to H11. search.
  unfold 1. witness P1, L1. split.
  apply extension_is to H9. search.
  search.

Theorem gid : forall P N, {dual P N} -> mall ($pf P :: $pf (shp N) :: nil).
intros. unfold 1. witness shp N, $pf P :: nil. split. search.
witness fshift N. split. search. unfold.
witness P. split. search. intros.
apply extension_exists to H2. witness L. split. search.
apply gid_lemma to H1 H2 H3.
witness $pf P :: L. split.
apply extension_is to H3. apply merge_nil_equal to H5. search.
unfold 1. witness P, L. split. apply extension_is to H3. search. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Permutations

Theorem mallfoc_perm : forall J F K,
  mallfoc J F -> perm J K -> mallfoc K F.
intros. case H1.
  apply perm_cons_1 to H2. case H4. case H3. search.
   case H5.
  unfold. witness P. split. search. intros.
   apply *H4 to *H5. apply perm_merge_1 to *H7 *H2. search.
  apply perm_merge_3 to *H3 *H2. search.
  case H2. search. case H3.

Theorem mall_perm : forall J K,
  mall J -> perm J K -> mall K.
intros. case H1. apply adj_perm_full to H2 H3.
apply mallfoc_perm to *H5 H7. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Full cut-elimination

Theorem $cut :
  (forall P N J JP K L,
    {dual P N} ->
    adj J ($pf P) JP -> mall JP ->
    (forall F KE KN,
     {subf F P} -> extension F KE -> merge K KE KN ->
     mall KN) ->
    merge J K L ->
    mall L)
/\
  (forall P N F J K KE KN L,
    {dual P N} ->
    {subf F P} -> mallfoc J F ->
    extension F KE -> merge K KE KN -> mall KN ->
    merge J K L ->
    mall L)
/\
  (forall P N F J JP K L,
    {dual P N} ->
    adj J ($pf P) JP -> mallfoc JP F ->
    (forall F KE KN,
     {subf F P} -> extension F KE -> merge K KE KN ->
     mall KN) ->
    merge J K L ->
    mallfoc L F).
IHrank1 : induction on 1 1 1. IHht1 : induction on 3 3 3. split.
intros. case H3.
  apply adj_same_result_diff_both to *H2 *H6. case H9.
    Hex : apply extension_exists to H7.
    Ht1 : apply merge_2_is_list to H5. Ht2 : apply extension_is to Hex.
    Hmr : apply merge_exists to *Ht1 *Ht2.
    apply *H4 to H7 Hex Hmr.
    apply perm_merge_1 to *H5 *H10.
    apply IHht2 to *H1 *H7 *H8 *Hex *Hmr *H11 *H12. search.

   apply merge_unadj_1 to *H5 *H10.
   apply perm_merge_1 to *H14 *H12.
   apply IHht3 to *H1 *H11 *H8 *H4 *H15.
   search.

intros Hdual Hsubf Hpos Hex Hexmr Hneg Hmr. Hdual1 : case Hdual.
  case Hsubf. case Hpos. case Hex.
    Hmr : apply merge_sym to *Hmr.
    apply merge_perm_det to *Hexmr *Hmr.
    backchain mall_perm.

  Hsubf1 : case Hsubf. Hpos : case Hpos. Hex1 : case Hex. rename Hex3 to Hex.
  Hn : assert 0 exists U, merge K L2 U /\ merge U L3 KN.
    apply merge_2_is_list to Hmr. apply merge_1_is_list to Hex.
    apply merge_exists to *H1 *H2. witness L1. split. search.
    backchain change_merge_order2. Hmr1 : case Hn.
  Hn : assert 0 exists V, merge K1 U V. backchain merge_exists.
    backchain merge_2_is_list. backchain merge_1_is_list. Hmr1 : case Hn.
  Hneg : apply IHrank2 to *Hdual2 *Hsubf2 *Hpos2 *Hex2 Hmr2 *Hneg Hmr3.
  Hn : assert 0 exists W, merge K1 K W /\ merge J1 W L.
     Hl1 : apply merge_2_is_list to Hpos.
     Hl1 : apply merge_1_is_list to Hmr1.
     Hn : apply merge_exists to *Hl1 *Hl2.
     witness L1. split. search.
     backchain change_merge_order.
     Hmr1 : case Hn.
  Hmr1 : assert 0 merge W L2 V. backchain change_merge_order2.
  Hneg : apply IHrank2 to *Hdual1 *Hsubf1 *Hpos1 *Hex1 Hmr6 *Hneg Hmr5.
  search.

  case Hsubf. case Hpos. case Hex. Hexmr : apply merge_sym to *Hexmr.
  Hp : apply merge_nil_perm to *Hmr. Hmr : apply perm_merge_2 to *Hexmr *Hp.
  Hp : apply merge_nil_perm to *Hmr. Hp : apply perm_sym to *Hp.
  backchain mall_perm.

  Hsubf : case Hsubf.
  backchain IHrank2.
  backchain IHrank2 with P = Q.

  case Hsubf.

  Hsubf : case Hsubf.
  Hdual1 : inst *Hdual1 with n1 = T.
  backchain IHrank2.

  Hsubf : case Hsubf.
  Hpos : case Hpos. Hex : case Hex.
  apply dual_det_1 to Hdual1 *Hsubf. apply dual_det_1 to Hdual1 *Hpos. apply dual_det_1 to Hdual1 *Hex.
  Hadj : assert 0 exists U, adj K ($pf P4) U /\ perm KN U.
     Hn1 : apply merge_unadj_2 to Hexmr _.
     Hn1 : apply merge_sym to *Hn2. Hp : apply merge_nil_perm to *Hn2.
     Hp : apply perm_sym to *Hp.
     Hp : apply adj_perm_source to *Hp *Hn1. search.
  Hadj : case Hadj. Hneg : apply mall_perm to *Hneg *Hadj1.
  Hmr : apply merge_sym to *Hmr.
  apply IHrank1 to *Hdual1 *Hadj *Hneg _ Hmr. intros Hsubf Hex Hmr.
    Hpos1 : apply *Hpos1 to *Hsubf. Hp : apply extension_det to  *Hex Hpos1.
    Hmr1 : apply perm_merge_2 to *Hmr1 *Hp.
    Hp : apply merge_perm_det to *Hpos2 *Hmr1.
    backchain mall_perm.
  search.

intros Hdual Hadj Hpos Hneg Hmr. Hpos : case Hpos.
  Hadj : case Hadj. case Hadj1.

  unfold 3. witness P1. split. search. intros Hsubf.
  Hpos1 : apply *Hpos1 to *Hsubf.
  witness LE. split. search.
  Hpos1 : apply merge_unadj_1 to *Hpos2 *Hadj.
  Hn : assert 0 exists U, merge LL1 K U. backchain merge_exists.
     backchain merge_3_is_list. backchain merge_2_is_list. Hmr1 : case Hn.
  apply IHht1 to *Hdual *Hpos2 *Hpos3 *Hneg Hmr1.
  witness U. split.
  Hmr : apply merge_sym to *Hmr. Hmr1 : apply merge_sym to *Hmr1.
  backchain change_merge_order2. search.

  Hadj1 : apply merge_unadj_3 to *Hpos *Hadj. Hadj1 : case Hadj1.
    Hn : assert 0 exists U, merge JJ K U. backchain merge_exists.
       backchain merge_1_is_list. backchain merge_2_is_list. Hmr1 : case Hn.
    apply IHht3 to *Hdual *Hadj1 *Hpos1 *Hneg Hmr1.
    assert merge U K1 L.
    Hmr1 : apply merge_sym to *Hmr1. apply merge_sym to *Hmr. backchain change_merge_order2.
    search.

    Hn : assert exists U, merge KK K U. backchain merge_exists.
       backchain merge_2_is_list. backchain merge_2_is_list. Hmr1 : case Hn.
    apply IHht3 to *Hdual *Hadj1 *Hpos2 *Hneg Hmr1.
    assert merge J1 U L. backchain change_merge_order.
    search.

  case Hadj.

Split $cut as cut_main, cut_principal, cut_commutative.